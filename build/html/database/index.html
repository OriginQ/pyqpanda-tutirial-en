
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>2 深入学习 &#8212; pyQPanda 1.0.0 文档</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="项目文档" href="../tool/index.html" />
    <link rel="prev" title="1 基础介绍" href="../api/index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="id1">
<h1><strong>2 深入学习</strong><a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<section id="id2">
<h2>2.1 <strong>量子逻辑门</strong><a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>经典计算中，最基本的单元是比特，而最基本的控制模式是逻辑门。我们可以通过逻辑门的组合来达到我们控制电路的目的。类似地，处理量子比特的方式就是量子逻辑门。使用量子逻辑门，我们有意识的使量子态发生演化。所以，量子逻辑门是构成量子算法的基础。</p>
<p>量子逻辑门由酉矩阵表示。最常见的量子门在一个或两个量子位的空间上工作，就像常见的经典逻辑门在一个或两个位上操作一样。</p>
<section id="id3">
<h3>2.1.1 常见量子逻辑门矩阵形式<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<section id="id4">
<h4>2.1.1.1单比特量子逻辑门<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<table class="docutils align-default">
<colgroup>
<col style="width: 27%" />
<col style="width: 4%" />
<col style="width: 69%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>` &lt;<a class="reference external" href="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_I.png">https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_I.png</a>&gt;`__</p></th>
<th class="head"><p>I</p></th>
<th class="head"><p><span class="math notranslate nohighlight">\(\left[\begin{array}{ll}1 &amp; 0 \\ 0 &amp; 1\end{array}\right]\)</span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>` &lt;<a class="reference external" href="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_H.png">https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_H.png</a>&gt;`__</p></td>
<td><p>Hadamard</p></td>
<td><p><span class="math notranslate nohighlight">\(\left[\begin{array}{cc}1 / \sqrt{2} &amp; 1 / \sqrt{2} \\ 1 / \sqrt{2} &amp; -1 / \sqrt{2}\end{array}\right]\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>` &lt;<a class="reference external" href="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_T.png">https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_T.png</a>&gt;`__</p></td>
<td><p>T</p></td>
<td><p><span class="math notranslate nohighlight">\(\left[\begin{array}{cc}1 &amp; 0 \\ 0 &amp; \exp (i \pi / 4)\end{array}\right]\)</span></p></td>
</tr>
<tr class="row-even"><td><p>` &lt;<a class="reference external" href="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_S.png">https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_S.png</a>&gt;`__</p></td>
<td><p>S</p></td>
<td><p><span class="math notranslate nohighlight">\(\left[\begin{array}{cc}1 &amp; 0 \\ 0 &amp; 1 i\end{array}\right]\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>` &lt;<a class="reference external" href="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_X.png">https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_X.png</a>&gt;`__</p></td>
<td><p>Pauli-X</p></td>
<td><p><span class="math notranslate nohighlight">\(\left[\begin{array}{ll}0 &amp; 1 \\ 1 &amp; 0\end{array}\right]\)</span></p></td>
</tr>
<tr class="row-even"><td><p>` &lt;<a class="reference external" href="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_Y.png">https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_Y.png</a>&gt;`__</p></td>
<td><p>Pauli-Y</p></td>
<td><p><span class="math notranslate nohighlight">\(\left[\begin{array}{cc}0 &amp; -1 i \\ 1 i &amp; 0\end{array}\right]\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>` &lt;<a class="reference external" href="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_Z.png">https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_Z.png</a>&gt;`__</p></td>
<td><p>Pauli-Z</p></td>
<td><p><span class="math notranslate nohighlight">\(\left[\begin{array}{cc}1 &amp; 0 \\ 0 &amp; -1\end{array}\right]\)</span></p></td>
</tr>
<tr class="row-even"><td><p>` &lt;<a class="reference external" href="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_X1.png">https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_X1.png</a>&gt;`__</p></td>
<td><p>X1</p></td>
<td><p><span class="math notranslate nohighlight">\(\left[\begin{array}{cc}1 / \sqrt{2} &amp; -1 i / \sqrt{2} \\ -1 i / \sqrt{2} &amp; 1 / \sqrt{2}\end{array}\right]\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>` &lt;<a class="reference external" href="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_Y1.png">https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_Y1.png</a>&gt;`__</p></td>
<td><p>Y1</p></td>
<td><p><span class="math notranslate nohighlight">\(\left[\begin{array}{cc}1 / \sqrt{2} &amp; -1 / \sqrt{2} \\ 1 / \sqrt{2} &amp; 1 / \sqrt{2}\end{array}\right]\)</span></p></td>
</tr>
<tr class="row-even"><td><p>` &lt;<a class="reference external" href="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_Z1.png">https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_Z1.png</a>&gt;`__</p></td>
<td><p>Z1</p></td>
<td><p><span class="math notranslate nohighlight">\(\left[\begin{array}{cc}\exp (-i \pi / 4) &amp; 0 \\ 0 &amp; \exp (i \pi / 4)\end{array}\right]\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>` &lt;<a class="reference external" href="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_RX.png">https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_RX.png</a>&gt;`__</p></td>
<td><p>RX</p></td>
<td><p><span class="math notranslate nohighlight">\(\left[\begin{array}{cc}\cos (\theta / 2) &amp; -1 i \times \sin (\theta / 2) \\ -1 i \times \sin (\theta / 2) &amp; \cos (\theta / 2)\end{array}\right]\)</span></p></td>
</tr>
<tr class="row-even"><td><p>` &lt;<a class="reference external" href="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_RY.png">https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_RY.png</a>&gt;`__</p></td>
<td><p>RY</p></td>
<td><p><span class="math notranslate nohighlight">\(\left[\begin{array}{cc}\cos (\theta / 2) &amp; -\sin (\theta / 2) \\ \sin (\theta / 2) &amp; \cos (\theta / 2)\end{array}\right]\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>` &lt;<a class="reference external" href="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_RZ.png">https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_RZ.png</a>&gt;`__</p></td>
<td><p>RZ</p></td>
<td><p><span class="math notranslate nohighlight">\(\left[\begin{array}{cc}\exp (-i \theta / 2) &amp; 0 \\ 0 &amp; \exp (i \theta / 2)\end{array}\right]\)</span></p></td>
</tr>
<tr class="row-even"><td><p>` &lt;<a class="reference external" href="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_U1.png">https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_U1.png</a>&gt;`__</p></td>
<td><p>U1</p></td>
<td><p><span class="math notranslate nohighlight">\(\left[\begin{array}{cc}1 &amp; 0 \\ 0 &amp; \exp (i \theta)\end{array}\right]\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>` &lt;<a class="reference external" href="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_U2.png">https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_U2.png</a>&gt;`__</p></td>
<td><p>U2</p></td>
<td><p><span class="math notranslate nohighlight">\(\left[\begin{array}{cc}1 / \sqrt{2} &amp; -\exp (i \lambda) / \sqrt{2} \\ \exp (i \phi) / \sqrt{2} &amp; \exp (i \lambda+i \phi) / \sqrt{2}\end{array}\right]\)</span></p></td>
</tr>
<tr class="row-even"><td><p>` &lt;<a class="reference external" href="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_U3.png">https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_U3.png</a>&gt;`__</p></td>
<td><p>U3</p></td>
<td><p><span class="math notranslate nohighlight">\(\left[\begin{array}{cc}\cos (\theta / 2) &amp; -\exp (i \lambda) \times \sin (\theta / 2) \\ \exp (i \phi) \times \sin (\theta / 2) &amp; \exp (i \lambda+i \phi) \times \cos (\theta / 2)\end{array}\right]\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>` &lt;<a class="reference external" href="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_U4.png">https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_U4.png</a>&gt;`__</p></td>
<td><p>U4</p></td>
<td><p><span class="math notranslate nohighlight">\(\left[\begin{array}{ll}u 0 &amp; u 1 \\ u 2 &amp; u 3\end{array}\right]\)</span></p></td>
</tr>
</tbody>
</table>
</section>
<section id="id5">
<h4>2.1.1.2 多比特量子逻辑门<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h4>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 3%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p>CNOT</p></th>
<th class="head"><p><span class="math notranslate nohighlight">\(\left[\begin{array}{llll}1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ 0 &amp; 0 &amp; 1 &amp; 0\end{array}\right]\)</span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>` &lt;<a class="reference external" href="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_CR.png">https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_CR.png</a>&gt;`__</p></td>
<td><p>CR</p></td>
<td><p><span class="math notranslate nohighlight">\(\left[\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; \exp (i \theta)\end{array}\right]\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>` &lt;<a class="reference external" href="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_iSWAP.png">https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_iSWAP.png</a>&gt;`__</p></td>
<td><p>iSWAP</p></td>
<td><p><span class="math notranslate nohighlight">\(\left[\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; \cos (\theta) &amp; -i \times \sin (\theta) &amp; 0 \\ 0 &amp; -i \times \sin (\theta) &amp; \cos (\theta) &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1\end{array}\right]\)</span></p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>SWAP</p></td>
<td><p><span class="math notranslate nohighlight">\(\left[\begin{array}{llll}1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1\end{array}\right]\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>` &lt;<a class="reference external" href="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_CZ.png">https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_CZ.png</a>&gt;`__</p></td>
<td><p>CZ</p></td>
<td><p><span class="math notranslate nohighlight">\(\left[\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; -1\end{array}\right]\)</span></p></td>
</tr>
<tr class="row-even"><td><p>` &lt;<a class="reference external" href="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_CU.png">https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_CU.png</a>&gt;`__</p></td>
<td><p>CU</p></td>
<td><p><span class="math notranslate nohighlight">\(\left[\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; u 0 &amp; u 1 \\ 0 &amp; 0 &amp; u 2 &amp; u 3\end{array}\right]\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>` &lt;<a class="reference external" href="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_Toff.png">https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_Toff.png</a>&gt;`__</p></td>
<td><p>Hadamard</p></td>
<td><p><span class="math notranslate nohighlight">\(\left[\begin{array}{llllllll}1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0\end{array}\right]\)</span></p></td>
</tr>
</tbody>
</table>
<p>QPanda2把所有的量子逻辑门封装为API向用户提供使用，并可获得QGate类型的返回值。比如，您想要使用Hadamard门，就可以通过如下方式获得：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">init</span><span class="p">(</span><span class="n">QMachineType</span><span class="o">.</span><span class="n">CPU</span><span class="p">)</span>
<span class="n">qubits</span> <span class="o">=</span> <span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>其中参数为目标比特，返回值为量子逻辑门。</p>
<p>pyqpanda中支持的不含角度的单门有： I 、 H 、 T 、 S 、 X 、 Y 、 Z 、 X1
、 Y1 、 Z1</p>
<p>qubit如何申请会在量子虚拟机部分介绍。</p>
<p>单门带有一个旋转角的逻辑门门，例如RX门：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>rx = RX(qubits[0]，np.pi/3)
</pre></div>
</div>
<p>第一个参数为目标比特，第二个参数为旋转角度。</p>
<p>pyqpanda中支持的单门带有一个旋转角度的逻辑门有： RX 、 RY 、 RZ 、U1、 P</p>
<p>pyqpanda中还支持 U2、U3、U4 门，其用法如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># U2(qubit, phi, lambda) 有两个角度
u2 = U2(qubits[0]，np.pi, np.pi/2)

# U3(qubit, theta, phi, lambda) 有三个角度
u3 = U3(qubits[0]，np.pi, np.pi/2, np.pi/4)

# U4(qubit, alpha, beta, gamma, delta) 有四个角度
u4 = U4(qubits[0]，np.pi, np.pi/2, np.pi/4, np.pi/2)
</pre></div>
</div>
<p>两比特量子逻辑门的使用和单比特量子逻辑门的用法相似，只不过是输入的参数不同，例如CNOT门：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>cnot = CNOT(qubits[0]，qubits[1])
</pre></div>
</div>
<p>第一个参数为控制比特，第二个参数为目标比特。（注：两个比特不能相同）</p>
<p>pyqpanda中支持的双门不含角度的逻辑门有：CNOT、CZ
、SWAP、iSWAp、SqiSWAP。</p>
<p>两比特量子逻辑门的使用和单比特量子逻辑门的用法相似，只不过是输入的参数不同，举个使用CNOT的例子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cnot</span> <span class="o">=</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">control_qubit</span><span class="p">,</span> <span class="n">target_qubit</span><span class="p">);</span>
</pre></div>
</div>
<p>CNOT门接收两个参数，第一个是控制比特，第二个是目标比特。</p>
<p>pyqpanda中支持的双门含旋转角度的逻辑门有：CR、CU 、CP</p>
<p>双门带有旋转角度的门，例如CR门：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># CU(control, target, alpha, beta, gamma, delta) 有四个角度
cu = CU(qubits[0]，qubits[1]，np.pi,np.pi/2,np.pi/3,np.pi/4)
</pre></div>
</div>
<p>第一个参数为控制比特, 第二个参数为目标比特，第三个参数为旋转角度。</p>
<p>支持CU门，使用方法如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># CU(control, target, alpha, beta, gamma, delta) 有四个角度
cu = CU(qubits[0]，qubits[1]，np.pi,np.pi/2,np.pi/3,np.pi/4)
</pre></div>
</div>
<p>获得三量子逻辑门 Toffoli 的方式：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">toffoli</span> <span class="o">=</span> <span class="n">Toffoli</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>三比特量子逻辑门Toffoli实际上是CCNOT门，前两个参数是控制比特，最后一个参数是目标比特。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">toffoli</span> <span class="o">=</span> <span class="n">Toffoli</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>pyqpanda还支持在量子逻辑门中添加量子比特数组操作，即将该数组中的所有量子比特赋予同一种逻辑门运算，举个使用单门H的例子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 这里返回的是一个量子线路</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span><span class="n">Qvec</span><span class="p">);</span>
</pre></div>
</div>
<p>这里的Qvec即为存放量子比特的数组。在对多门进行数组操作时，则是传入对应的多个数组，并按照数组下标顺序进行逻辑门运算。</p>
</section>
</section>
<section id="id6">
<h3>2.1.2 接口介绍<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>在本章的开头介绍过，所有的量子逻辑门都是酉矩阵，那么您也可以对量子逻辑门做转置共轭操作，获得一个量子逻辑门
dagger 之后的量子逻辑门可以用下面的方法：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rx_dagger</span> <span class="o">=</span> <span class="n">RX</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">dagger</span><span class="p">()</span>
</pre></div>
</div>
<p>或：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rx_dagger</span> <span class="o">=</span> <span class="n">RX</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="n">rx_dagger</span><span class="o">.</span><span class="n">set_dagger</span><span class="p">(</span><span class="n">true</span><span class="p">)</span>
</pre></div>
</div>
<p>也可以为量子逻辑门添加控制比特,获得一个量子逻辑门 control
之后的量子逻辑门可以用下面的方法：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>qvec = [qubits[0], qubits[1]]
rx_control = RX(qubits[2], np.pi).control(qvec)或：
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qvec</span> <span class="o">=</span> <span class="p">[</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
<span class="n">rx_control</span> <span class="o">=</span> <span class="n">RX</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="n">rx_control</span><span class="o">.</span><span class="n">set_control</span><span class="p">(</span><span class="n">qvec</span><span class="p">)</span>
</pre></div>
</div>
<p>pyqpanda 还封装了一些比较方便的接口，会简化一些量子逻辑门的操作。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cir</span> <span class="o">=</span> <span class="n">apply_QGate</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>
</pre></div>
</div>
<p>qubits的每个量子比特都添加H门。</p>
</section>
<section id="id7">
<h3>2.1.3 实例<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>以下实例主要是向您展现QGate类型接口的使用方式。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
   <span class="n">init</span><span class="p">(</span><span class="n">QMachineType</span><span class="o">.</span><span class="n">CPU</span><span class="p">)</span>
   <span class="n">qubits</span> <span class="o">=</span> <span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
   <span class="n">control_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
   <span class="n">prog</span> <span class="o">=</span> <span class="n">create_empty_qprog</span><span class="p">()</span>

   <span class="c1"># 构建量子程序</span>
   <span class="n">prog</span>  <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span> \
         <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">dagger</span><span class="p">()</span> \
         <span class="o">&lt;&lt;</span> <span class="n">X</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">control</span><span class="p">(</span><span class="n">control_qubits</span><span class="p">)</span>

   <span class="c1"># 对量子程序进行概率测量</span>
   <span class="n">result</span> <span class="o">=</span> <span class="n">prob_run_dict</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">qubits</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

   <span class="c1"># 打印测量结果</span>
   <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
   <span class="n">finalize</span><span class="p">()</span>
</pre></div>
</div>
<p>计算结果如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;000&#39;</span><span class="p">:</span> <span class="mf">0.24999999999999295</span><span class="p">,</span> <span class="s1">&#39;001&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;010&#39;</span><span class="p">:</span> <span class="mf">0.24999999999999295</span><span class="p">,</span> <span class="s1">&#39;011&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;100&#39;</span><span class="p">:</span> <span class="mf">0.24999999999999295</span><span class="p">,</span> <span class="s1">&#39;101&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;110&#39;</span><span class="p">:</span> <span class="mf">0.24999999999999295</span><span class="p">,</span> <span class="s1">&#39;111&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id8">
<h2><strong>2.2 量子线路</strong><a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p>量子线路，也称量子逻辑电路是最常用的通用量子计算模型，表示在抽象概念下，对于量子比特进行操作的线路。组成包括了量子比特、线路（时间线），以及各种逻辑门。最后常需要量子测量将结果读取出来。</p>
<p>不同于传统电路是用金属线所连接以传递电压讯号或电流讯号，在量子线路中，线路是由时间所连接，亦即量子比特的状态随着时间自然演化，过程中是按照哈密顿运算符的指示，一直到遇上逻辑门而被操作。</p>
<p>由于组成量子线路的每一个量子逻辑门都是一个 酉算子
，所以整个量子线路整体也是一个大的酉算子。</p>
<section id="id9">
<h3>2.2.1 量子算法线路图<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<p>在目前的量子计算理论研究中，各种量子算法常用量子线路表示，比如下方列出的量子算法中的
HHL算法 量子线路图。</p>
<figure class="align-default" id="id55">
<img alt="*images/HHL*\ Alg.png" src="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/HHL_Alg.png" />
<figcaption>
<p><span class="caption-text"><em>images/HHL</em>Alg.png</span><a class="headerlink" href="#id55" title="永久链接至图片">¶</a></p>
</figcaption>
</figure>
</section>
<section id="id10">
<h3>2.2.2 接口介绍<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>在QPanda2中，QCircuit类是一个仅装载量子逻辑门的容器类型，它也是QNode中的一种，初始化一个QCircuit对象有以下两种：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cir</span> <span class="o">=</span> <span class="n">QCircuit</span><span class="p">()</span>
</pre></div>
</div>
<p>或：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cir</span> <span class="o">=</span> <span class="n">create_empty_circuit</span><span class="p">()</span>
</pre></div>
</div>
<p>你可以通过如下方式向QCircuit尾部填充节点，在这里pyqpanda重载了 &lt;&lt;
运算符作为插入量子线路的方法。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cir</span> <span class="o">&lt;&lt;</span> <span class="n">node</span>
</pre></div>
</div>
<p>node的类型可以为QGate或QCircuit。</p>
<p>我们还可以获得QCircuit的转置共轭之后的量子线路，使用方式为：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cir_dagger</span> <span class="o">=</span> <span class="n">cir</span><span class="o">.</span><span class="n">dagger</span><span class="p">()</span>
</pre></div>
</div>
<p>如果想复制当前的量子线路，并给复制的量子线路添加控制比特，可以使用下面的方式：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qvec</span> <span class="o">=</span> <span class="p">[</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
<span class="n">cir_control</span> <span class="o">=</span> <span class="n">cir</span><span class="o">.</span><span class="n">control</span><span class="p">(</span><span class="n">qvec</span><span class="p">)</span>
</pre></div>
</div>
<p><em>注解：</em></p>
<ol class="arabic simple">
<li><p>向QCircuit中插入QPorg，QIf，Measure中不会报错，但是运行过程中可能会产生预料之外的错误；</p></li>
<li><p>一个构建好的QCircuit不能直接参与量子计算与模拟，需要进一步构建成QProg类型。</p></li>
</ol>
</section>
<section id="id11">
<h3>2.2.3 实例<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>

    <span class="n">init</span><span class="p">(</span><span class="n">QMachineType</span><span class="o">.</span><span class="n">CPU</span><span class="p">)</span>
    <span class="n">qubits</span> <span class="o">=</span> <span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">cbits</span> <span class="o">=</span> <span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

    <span class="c1"># 构建量子程序</span>
    <span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
    <span class="n">circuit</span> <span class="o">=</span> <span class="n">create_empty_circuit</span><span class="p">()</span>

    <span class="n">circuit</span> <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> \
            <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> \
            <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> \
            <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

    <span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">circuit</span> <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cbits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># 量子程序运行1000次，并返回测量结果</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">run_with_configuration</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">cbits</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>

    <span class="c1"># 打印量子态在量子程序多次运行结果中出现的次数</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="n">finalize</span><span class="p">()</span>
</pre></div>
</div>
<p>运行结果：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;0000&#39;</span><span class="p">:</span> <span class="mi">486</span><span class="p">,</span> <span class="s1">&#39;0001&#39;</span><span class="p">:</span> <span class="mi">514</span><span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="qwhile">
<h2><strong>2.3 QWhile</strong><a class="headerlink" href="#qwhile" title="永久链接至标题">¶</a></h2>
<p>量子程序循环控制操作，输入参数为条件判断表达式，功能是执行while循环操作。</p>
<section id="id12">
<h3>2.3.1 接口介绍<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h3>
<p>在QPanda2中，QWhileProg类用于表示执行量子程序while循环操作，它也是QNode中的一种，初始化一个QWhileProg对象有以下两种：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qwile</span> <span class="o">=</span> <span class="n">QWhileProg</span><span class="p">(</span><span class="n">ClassicalCondition</span><span class="p">,</span> <span class="n">QNode</span><span class="p">)</span>
</pre></div>
</div>
<p>或</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qwile</span> <span class="o">=</span> <span class="n">create_while_prog</span><span class="p">(</span><span class="n">ClassicalCondition</span><span class="p">,</span> <span class="n">QNode</span><span class="p">)</span>
</pre></div>
</div>
<p>上述函数需要提供两个参数，即ClassicalCondition量子表达式与QNode节点可以传入的QNode类型有：QProg、QCircuit、QGate、QWhileProg、QIfProg、QMeasure。</p>
</section>
<section id="id13">
<h3>2.3.2 实例<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>

    <span class="n">init</span><span class="p">(</span><span class="n">QMachineType</span><span class="o">.</span><span class="n">CPU</span><span class="p">)</span>
    <span class="n">qubits</span> <span class="o">=</span> <span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">cbits</span> <span class="o">=</span> <span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">cbits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_val</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">cbits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_val</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
    <span class="n">prog_while</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>

    <span class="c1"># 构建QWhile的循环分支</span>
    <span class="n">prog_while</span> <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>\
            <span class="o">&lt;&lt;</span> <span class="n">assign</span><span class="p">(</span><span class="n">cbits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cbits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cbits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># 构建QWhile</span>
    <span class="n">qwhile</span> <span class="o">=</span> <span class="n">create_while_prog</span><span class="p">(</span><span class="n">cbits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">prog_while</span><span class="p">)</span>

    <span class="c1"># QWhile插入到量子程序中</span>
    <span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">qwhile</span>

    <span class="c1"># 运行，并打印测量结果</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">directly_run</span><span class="p">(</span><span class="n">prog</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">cbits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_val</span><span class="p">())</span>
    <span class="n">finalize</span><span class="p">()</span>
</pre></div>
</div>
<p>运行结果：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">2</span>
<span class="p">{</span><span class="s1">&#39;c1&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="qif">
<h2><strong>2.4 QIf</strong><a class="headerlink" href="#qif" title="永久链接至标题">¶</a></h2>
<p>QIf表示量子程序条件判断操作，输入参数为条件判断表达式，功能是执行条件判断。</p>
<section id="id14">
<h3>2.4.1 接口介绍<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<p>在QPanda2中，QIfProg类用于表示执行量子程序条件判断操作，它也是QNode中的一种，初始化一个QIfProg对象有以下两种：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qif</span> <span class="o">=</span> <span class="n">QIfProg</span><span class="p">(</span><span class="n">ClassicalCondition</span><span class="p">,</span> <span class="n">QNode</span><span class="p">)</span>
<span class="n">qif</span> <span class="o">=</span> <span class="n">QIfProg</span><span class="p">(</span><span class="n">ClassicalCondition</span><span class="p">,</span> <span class="n">QNode</span><span class="p">,</span> <span class="n">QNode</span><span class="p">)</span>
</pre></div>
</div>
<p>或</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qif</span> <span class="o">=</span> <span class="n">create_if_prog</span><span class="p">(</span><span class="n">ClassicalCondition</span><span class="p">,</span> <span class="n">QNode</span><span class="p">)</span>
<span class="n">qif</span> <span class="o">=</span> <span class="n">create_if_prog</span><span class="p">(</span><span class="n">ClassicalCondition</span><span class="p">,</span> <span class="n">QNode</span><span class="p">,</span> <span class="n">QNode</span><span class="p">)</span>
</pre></div>
</div>
<p>上述函数需要提供两种类型参数，即ClassicalCondition量子表达式与QNode节点，
当传入1个QNode参数时，QNode表示正确分支节点，当传入2个QNode参数时，第一个表示正确分支节点，第二个表示错误分支节点。
可以传入的QNode类型有：
QProg、QCircuit、QGate、QWhileProg、QIfProg、QMeasure。</p>
</section>
<section id="id15">
<h3>2.4.2 实例<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>

    <span class="n">init</span><span class="p">(</span><span class="n">QMachineType</span><span class="o">.</span><span class="n">CPU</span><span class="p">)</span>
    <span class="n">qubits</span> <span class="o">=</span> <span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">cbits</span> <span class="o">=</span> <span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">cbits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_val</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">cbits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_val</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

    <span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
    <span class="n">branch_true</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
    <span class="n">branch_false</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>

    <span class="c1"># 构建QIf正确分支以及错误分支</span>
    <span class="n">branch_true</span> <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">branch_false</span> <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="c1"># 构建QIf</span>
    <span class="n">qif</span> <span class="o">=</span> <span class="n">create_if_prog</span><span class="p">(</span><span class="n">cbits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cbits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">branch_true</span><span class="p">,</span> <span class="n">branch_false</span><span class="p">)</span>

    <span class="c1"># QIf插入到量子程序中</span>
    <span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">qif</span>

    <span class="c1"># 概率测量，并返回目标量子比特的概率测量结果，下标为十进制</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">prob_run_tuple_list</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">qubits</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># 打印概率测量结果</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="n">finalize</span><span class="p">()</span>
</pre></div>
</div>
<p>运行结果：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.4999999999999999</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mf">0.4999999999999999</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)]</span>
</pre></div>
</div>
</section>
</section>
<section id="id16">
<h2><strong>2.5 量子程序</strong><a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h2>
<p>量子程序设计用于量子程序的编写与构造，一般地，
可以理解为一个操作序列。由于量子算法中也会包含经典计算，因而业界设想，最近将来出现的量子计算机是混合结构的，它包含两大部分一部分是经典计算机，负责执行经典计算与控制；另一部分是量子设备，负责执行量子计算。QPanda-2将量子程序的编程过程视作经典程序运行的一部分，在整个外围的宿主机程序中，一定包含创建量子程序的部分。</p>
<section id="id17">
<h3>2.5.1 接口介绍<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h3>
<p>在QPanda2中，QProg是量子编程的一个容器类，是一个量子程序的最高单位。它也是QNode中的一种，初始化一个QProg对象有以下两种：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
</pre></div>
</div>
<p>或</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prog</span> <span class="o">=</span> <span class="n">create_empty_qprog</span><span class="p">()</span>
</pre></div>
</div>
<p>还可以由已有的QNode节点来构建量子程序，如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qubit</span> <span class="o">=</span> <span class="n">qAlloc</span><span class="p">()</span>
<span class="n">gate</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>
<span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">(</span><span class="n">gate</span><span class="p">)</span>
</pre></div>
</div>
<p>可以用类似的方式构建量子程序的有QCircuit、QGate、QWhileProg、QIfProg、ClassicalCondition、QMeasure。</p>
<p>你可以通过如下方式向QProg尾部填充节点, 在这里pyqpanda重载了 &lt;&lt;
运算符作为插入量子线路的方法。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">node</span>
</pre></div>
</div>
<p>QNode的类型有QGate，QPorg，QIf，Measure等等，QProg支持插入所有类型的QNode。</p>
</section>
<section id="id18">
<h3>2.5.2 实例<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>

    <span class="n">init</span><span class="p">(</span><span class="n">QMachineType</span><span class="o">.</span><span class="n">CPU</span><span class="p">)</span>
    <span class="n">qubits</span> <span class="o">=</span> <span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">cbits</span> <span class="o">=</span> <span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>

    <span class="c1"># 构建量子程序</span>
    <span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> \
         <span class="o">&lt;&lt;</span> <span class="n">X</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> \
         <span class="o">&lt;&lt;</span> <span class="n">iSWAP</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> \
         <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> \
         <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> \
         <span class="o">&lt;&lt;</span> <span class="n">measure_all</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">cbits</span><span class="p">)</span>

    <span class="c1"># 量子程序运行1000次，并返回测量结果</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">run_with_configuration</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">cbits</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>

    <span class="c1"># 打印量子态在量子程序多次运行结果中出现的次数</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="n">finalize</span><span class="p">()</span>
</pre></div>
</div>
<p>运行结果：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;1000&#39;</span><span class="p">:</span> <span class="mi">272</span><span class="p">,</span> <span class="s1">&#39;1001&#39;</span><span class="p">:</span> <span class="mi">261</span><span class="p">,</span> <span class="s1">&#39;1110&#39;</span><span class="p">:</span> <span class="mi">220</span><span class="p">,</span> <span class="s1">&#39;1111&#39;</span><span class="p">:</span> <span class="mi">247</span><span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id19">
<h2><strong>2.6 量子虚拟机</strong><a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h2>
<p>在真正的量子计算机没有成型之前，需要使用量子虚拟机承担量子算法、量子应用的验证的问题，QPanda2现在支持全振幅量子虚拟机、单振幅量子虚拟机、部分振幅量子虚拟机以及含噪声量子虚拟机。</p>
<section id="id20">
<h3>2.6.1 全振幅量子虚拟机<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h3>
<p>全振幅量子虚拟机一次可以模拟计算出量子态的所有振幅，计算方式支持CPU、单线程计算和GPU，可以在初始化时配置，使用方式是完全一样的，只是其计算效率不同.</p>
<section id="id21">
<h4>2.6.1.1 接口介绍<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h4>
<p>全振幅量子虚拟机类型：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">QMachineType</span><span class="p">(</span><span class="n">__pybind11_builtins</span><span class="o">.</span><span class="n">pybind11_object</span><span class="p">):</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Members:</span>

<span class="sd">    CPU</span>

<span class="sd">    GPU</span>

<span class="sd">    CPU_SINGLE_THREAD</span>

<span class="sd">    NOISE</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>QPanda2中在构造量子虚拟机时有以下几种方式：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">init</span><span class="p">(</span><span class="n">QMachineType</span><span class="o">.</span><span class="n">CPU</span><span class="p">)</span>  <span class="c1"># 使用init,不会返回qvm，会在代码中生成一个全局的qvm</span>
<span class="n">auto</span> <span class="n">qvm</span> <span class="o">=</span> <span class="n">init_quantum_machine</span><span class="p">(</span><span class="n">QMachineType</span><span class="o">.</span><span class="n">CPU</span><span class="p">)</span> <span class="c1"># 通过接口得到quantum machine对象</span>
<span class="n">qvm</span> <span class="o">=</span> <span class="n">CPUQVM</span><span class="p">()</span> <span class="c1"># 新建一个quantum machine对象</span>
</pre></div>
</div>
<p><em>注解：</em></p>
<p>init和 init_quantum_machine
这两个函数不是线程安全的，不适用于多线程编程，而且其最大的量子比特个数和经典寄存器个数均为默认值25。</p>
<p>设置好配置之后要初始化量子虚拟机：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qvm</span><span class="o">.</span><span class="n">init_qvm</span><span class="p">()</span>
</pre></div>
</div>
<p><em>注解：</em></p>
<p>调用 init 和 init_quantum_machine 接口， 就不需要初始化了。</p>
<p>下面我们就需要去申请量子比特和经典寄存器。</p>
<p>设置最大量子比特个数</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 设置最大量子比特个数和最大经典寄存器个数</span>
<span class="n">qvm</span><span class="o">.</span><span class="n">set_configure</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
</pre></div>
</div>
<p><em>注解：</em></p>
<p>若不设置则默认最大比特为29。</p>
<p>例如我们申请4个量子比特：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qubits</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>申请一个量子比特时也可以用这个接口：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qubit</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">qAlloc</span><span class="p">()</span>
</pre></div>
</div>
<p>申请经典寄存器也有类似于申请量子比特的接口，其使用方法和申请量子比特的方法一样，如申请4个经典寄存器的方法：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cbits</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>申请一个经典寄存器时也可以用这个接口：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cbit</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">cAlloc</span><span class="p">()</span>
</pre></div>
</div>
<p>在一个量子虚拟机中，申请了几次量子比特或经典寄存器，我们想知道一共申请了多少个量子比特或经典寄存器可以用下面的方法：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">num_qubit</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">get_allocate_qubit_num</span><span class="p">()</span> <span class="c1"># 申请量子比特的个数</span>
<span class="n">num_cbit</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">get_allocate_cmem_num</span><span class="p">()</span> <span class="c1"># 申请经典寄存器的个数</span>
</pre></div>
</div>
<p>我们该如何使用量子虚拟机来执行量子程序呢？ 可以用下面的方法：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
<span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cbits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">directly_run</span><span class="p">(</span><span class="n">prog</span><span class="p">)</span> <span class="c1"># 执行量子程序</span>
</pre></div>
</div>
<p>如果想多次运行一个量子程序，并得到每次量子程序的结果，除了循环调用
directly_run 方法外， 我们还提供了一个接口 run_with_configuration
，该接口有两种重载方法，具体方法如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">run_with_configuration</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">cbits</span><span class="p">,</span> <span class="n">shots</span><span class="p">)</span>
</pre></div>
</div>
<p>一种方法中 prog 为量子程序， cbits 为 ClassicalCondition list， shots
是一个整形数据，为量子程序运行次数。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">run_with_configuration</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">cbits</span><span class="p">,</span> <span class="n">config</span><span class="p">)</span>
</pre></div>
</div>
<p>另一种方法中 prog 为量子程序， cbits 为 ClassicalCondition list, config
是一个字典类型的数据，内容如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">config</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;shots&#39;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">}</span>
</pre></div>
</div>
<p>如果想得到量子程序运行之后各个量子态的振幅值，可以调用 get_qstate
函数获得：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stat</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">get_qstate</span><span class="p">()</span>
</pre></div>
</div>
<p>量子虚拟机中测量和概率使用方法与<a class="reference external" href="#_2.8量子测量">量子测量</a>和<a class="reference external" href="#_2.9概率测量">概率测量</a>中介绍的相同，在这里就不多做赘述。</p>
</section>
<section id="id22">
<h4>2.6.1.2 实例1<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">qvm</span> <span class="o">=</span> <span class="n">CPUQVM</span><span class="p">()</span>
    <span class="n">qvm</span><span class="o">.</span><span class="n">init_qvm</span><span class="p">()</span>

    <span class="n">qvm</span><span class="o">.</span><span class="n">set_configure</span><span class="p">(</span><span class="mi">29</span><span class="p">,</span> <span class="mi">29</span><span class="p">)</span>
    <span class="n">qubits</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">cbits</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

    <span class="c1"># 构建量子程序</span>
    <span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
    <span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cbits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># 量子程序运行1000次，并返回测量结果</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">run_with_configuration</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">cbits</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>

    <span class="c1"># 打印量子态在量子程序多次运行结果中出现的次数</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="n">qvm</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
</pre></div>
</div>
<p>运行结果：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;0000&#39;</span><span class="p">:</span> <span class="mi">481</span><span class="p">,</span> <span class="s1">&#39;1000&#39;</span><span class="p">:</span> <span class="mi">519</span><span class="p">}</span>
</pre></div>
</div>
<p><em>注解：</em></p>
<p>这个量子程序的运行结果是不确定的，但其 0000 和 0001
对应的值都应该在500左右。</p>
<p>为了方便使用，pyqpanda还封装了一些面向过程的接口，接口名称和使用方法与上述的基本相同。我们将上面的例子修改为面向过程的接口如下：</p>
</section>
<section id="id23">
<h4>2.6.1.3 实例2<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">init</span><span class="p">(</span><span class="n">QMachineType</span><span class="o">.</span><span class="n">CPU</span><span class="p">)</span>
    <span class="n">qubits</span> <span class="o">=</span> <span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">cbits</span> <span class="o">=</span> <span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

    <span class="c1"># 构建量子程序</span>
    <span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
    <span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cbits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># 量子程序运行1000次，并返回测量结果</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">run_with_configuration</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">cbits</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>

    <span class="c1"># 打印量子态在量子程序多次运行结果中出现的次数</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="n">finalize</span><span class="p">()</span>
</pre></div>
</div>
<p>运行结果：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;0000&#39;</span><span class="p">:</span> <span class="mi">484</span><span class="p">,</span> <span class="s1">&#39;1000&#39;</span><span class="p">:</span> <span class="mi">516</span><span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id24">
<h3>2.6.2 含噪声量子虚拟机<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h3>
<p>在真实的量子计算机中，受制于量子比特自身的物理特性，常常存在不可避免的计算误差。为了能在量子虚拟机中更好的模拟这种误差，在<a class="reference external" href="#_2.6量子虚拟机">量子虚拟机</a>的基础上，
QPanda2带来了含噪声量子虚拟机。含噪声量子虚拟机的模拟更贴近真实的量子计算机，我们可以自定义支持的逻辑门类型，自定义逻辑门支持的噪声模型，
通过这些自定义形式，我们使用QPanda2开发量子程序的现实应用程度将更高。</p>
<section id="id25">
<h4>2.6.2.1 噪声模型介绍<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h4>
<ol class="arabic simple">
<li><p>DAMPING_KRAUS_OPERATOR</p></li>
</ol>
<p>DAMPING_KRAUS_OPERATOR是量子比特的弛豫过程噪声模型，它的kraus算符和表示方法如下所示：</p>
<p><span class="math notranslate nohighlight">\(K_{1}=\left[\begin{array}{cc}1 &amp; 0 \\ 0 &amp; \sqrt{1-p}\end{array}\right], K_{2}=\left[\begin{array}{cc}0 &amp; \sqrt{p} \\ 0 &amp; 0\end{array}\right]\)</span></p>
<p>需要一个噪声参数。</p>
<ol class="arabic simple" start="2">
<li><p>DEPHASING_KRAUS_OPERATOR</p></li>
</ol>
<p>DEPHASING_KRAUS_OPERATOR是量子比特的退相位过程噪声模型，它的kraus算符和表示方法如下所示：</p>
<p><span class="math notranslate nohighlight">\(K_{1}=\left[\begin{array}{cc}\sqrt{1-p} &amp; 0 \\ 0 &amp; \sqrt{1-p}\end{array}\right], K_{2}=\left[\begin{array}{cc}\sqrt{p} &amp; 0 \\ 0 &amp; -\sqrt{p}\end{array}\right]\)</span></p>
<p>需要一个噪声参数。</p>
<ol class="arabic simple" start="3">
<li><p>DECOHERENCE_KRAUS_OPERATOR</p></li>
</ol>
<p>DECOHERENCE_KRAUS_OPERATOR是退相干噪声模型，为上述两种噪声模型的综合，他们的关系如下所示：</p>
<p><span class="math notranslate nohighlight">\(P_{\text {damping }}=1-e^{-\frac{t_{\text {gate }}}{T_{1}}}, P_{\text {dephasing }}=0.5 \times\left(1-e^{-\left(\frac{t_{\text {gate }}}{T_{2}}-\frac{\text { tgate }}{2 T_{1}}\right)}\right)\)</span>
<span class="math notranslate nohighlight">\(K_{1}=K_{1 \text { damping }} K_{1 \text { dephasing }} K_{2}=K_{1 \text { damping }} K_{2 \text { dephasing }}\)</span>
<span class="math notranslate nohighlight">\(K_{3}=K_{2 \text { dampin }} K_{1 \text { dephasing }} K_{4}=K_{2 \text { dampin }} K_{2 \text { dephasing }}\)</span></p>
<p>需要三个噪声参数。</p>
<ol class="arabic simple" start="4">
<li><p>DEPOLARIZING_KRAUS_OPERATOR</p></li>
</ol>
<p>DEPOLARIZING_KRAUS_OPERATOR去极化噪声模型，即单量子比特有一定的概率被完全混合态I/2代替,
它的kraus算符和表示方法如下所示：</p>
<p><span class="math notranslate nohighlight">\(K_{1}=\sqrt{1-3 p / 4} \times I, K_{2}=\sqrt{p} / 2 \times X\)</span>
<span class="math notranslate nohighlight">\(K_{3}=\sqrt{p} / 2 \times Y, K_{4}=\sqrt{p} / 2 \times Z\)</span></p>
<p>其中I、X、Y、Z分别代表其量子逻辑门对应的矩阵</p>
<p>需要一个参数</p>
<ol class="arabic simple" start="5">
<li><p>BITFLIP_KRAUS_OPERATOR</p></li>
</ol>
<p>BITFLIP_KRAUS_OPERATOR是比特反转噪声模型，它的kraus算符和表示方法如下所示：</p>
<p><span class="math notranslate nohighlight">\(K_{1}=\left[\begin{array}{cc}\sqrt{1-p} &amp; 0 \\ 0 &amp; \sqrt{1-p}\end{array}\right], K_{2}=\left[\begin{array}{cc}0 &amp; \sqrt{p} \\ \sqrt{p} &amp; 0\end{array}\right]\)</span></p>
<p>需要一个噪声参数。</p>
<ol class="arabic simple" start="6">
<li><p>BIT_PHASE_FLIP_OPRATOR</p></li>
</ol>
<p>BIT_PHASE_FLIP_OPRATOR是比特-相位反转噪声模型，它的kraus算符和表示方法如下所示：</p>
<p><span class="math notranslate nohighlight">\(K_{1}=\left[\begin{array}{cc}\sqrt{1-p} &amp; 0 \\ 0 &amp; \sqrt{1-p}\end{array}\right], K_{2}=\left[\begin{array}{cc}0 &amp; -i \times \sqrt{p} \\ i \times \sqrt{p} &amp; 0\end{array}\right]\)</span></p>
<p>需要一个噪声参数。</p>
<ol class="arabic simple" start="7">
<li><p>PHASE_DAMPING_OPRATOR</p></li>
</ol>
<p>PHASE_DAMPING_OPRATOR是相位阻尼噪声模型，它的kraus算符和表示方法如下所示：</p>
<p><span class="math notranslate nohighlight">\(K_{1}=\left[\begin{array}{cc}1 &amp; 0 \\ 0 &amp; \sqrt{1-p}\end{array}\right], K_{2}=\left[\begin{array}{cc}0 &amp; 0 \\ 0 &amp; \sqrt{p}\end{array}\right]\)</span></p>
<p>需要一个噪声参数。</p>
<ol class="arabic simple" start="8">
<li><p>双门噪声模型</p></li>
</ol>
<p>双门噪声模型同样也分为上述几种：</p>
<p>DAMPING_KRAUS_OPERATOR、DEPHASING_KRAUS_OPERATOR、</p>
<p>DECOHERENCE_KRAUS_OPERATOR、</p>
<p>DEPOLARIZING_KRAUS_OPERATOR、BITFLIP_KRAUS_OPERATOR、</p>
<p>BIT_PHASE_FLIP_OPRATOR、PHASE_DAMPING_OPRATOR。</p>
<p>它们的输入参数与单门噪声模型一致，双门噪声模型的kraus算符和表示与单门噪声模型存在着对应关系：假设单门噪声模型为：<span class="math notranslate nohighlight">\({K1,K2}\)</span>
，那么对应的双门噪声模型为$ {K1⊗K1,K1⊗K2,K2⊗K1,K2⊗K2}$。</p>
</section>
<section id="id26">
<h4>2.6.2.2 接口介绍<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h4>
<p>pyqpanda当前支持的噪声模型</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NoiseModel</span><span class="p">(</span><span class="n">__pybind11_builtins</span><span class="o">.</span><span class="n">pybind11_object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Members:</span>

<span class="sd">    DAMPING_KRAUS_OPERATOR</span>

<span class="sd">    DECOHERENCE_KRAUS_OPERATOR</span>

<span class="sd">    DEPHASING_KRAUS_OPERATOR</span>

<span class="sd">    PAULI_KRAUS_MAP</span>

<span class="sd">    DECOHERENCE_KRAUS_OPERATOR_P1_P2</span>

<span class="sd">    BITFLIP_KRAUS_OPERATOR</span>

<span class="sd">    DEPOLARIZING_KRAUS_OPERATOR</span>

<span class="sd">    BIT_PHASE_FLIP_OPRATOR</span>

<span class="sd">    PHASE_DAMPING_OPRATOR</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<p>设置一个噪声参数的使用方法如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">qvm</span> <span class="o">=</span> <span class="n">NoiseQVM</span><span class="p">()</span>
<span class="n">qvm</span><span class="o">.</span><span class="n">init_qvm</span><span class="p">()</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="c1"># 未指定作用比特则对所有比特生效</span>
<span class="n">qvm</span><span class="o">.</span><span class="n">set_noise_model</span><span class="p">(</span><span class="n">NoiseModel</span><span class="o">.</span><span class="n">BITFLIP_KRAUS_OPERATOR</span><span class="p">,</span> <span class="n">GateType</span><span class="o">.</span><span class="n">PAULI_X_GATE</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="c1"># 制定比特时，仅对指定的比特生效</span>
<span class="n">qvm</span><span class="o">.</span><span class="n">set_noise_model</span><span class="p">(</span><span class="n">NoiseModel</span><span class="o">.</span><span class="n">BITFLIP_KRAUS_OPERATOR</span><span class="p">,</span> <span class="n">GateType</span><span class="o">.</span><span class="n">RY_GATE</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="c1"># 双门指定比特时, 需要同时指定两个比特，且对比特的顺序敏感</span>
<span class="n">qvm</span><span class="o">.</span><span class="n">set_noise_model</span><span class="p">(</span><span class="n">NoiseModel</span><span class="o">.</span><span class="n">DAMPING_KRAUS_OPERATOR</span><span class="p">,</span> <span class="n">GateType</span><span class="o">.</span><span class="n">CNOT_GATE</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="p">[[</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]]])</span>
<span class="c1">#可对线路中所有types加噪声</span>
<span class="n">qvm</span><span class="o">.</span><span class="n">set_noise_model</span><span class="p">(</span><span class="n">NoiseModel</span><span class="o">.</span><span class="n">BITFLIP_KRAUS_OPERATOR</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="n">qvm</span><span class="o">.</span><span class="n">set_noise_model</span><span class="p">(</span><span class="n">NoiseModel</span><span class="o">.</span><span class="n">DECOHERENCE_KRAUS_OPERATOR</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>
<span class="n">qvm</span><span class="o">.</span><span class="n">set_noise_model</span><span class="p">(</span><span class="n">NoiseModel</span><span class="o">.</span><span class="n">DAMPING_KRAUS_OPERATOR</span><span class="p">,</span> <span class="n">GateType</span><span class="o">.</span><span class="n">CNOT_GATE</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
</pre></div>
</div>
<p>第一个参数为噪声模型类型，第二个参数为量子逻辑门类型，第三个参数为噪声模型所需的参数。</p>
<p>设置三个噪声参数的使用方法如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 未指定作用比特则对所有比特生效</span>
<span class="n">qvm</span><span class="o">.</span><span class="n">set_noise_model</span><span class="p">(</span><span class="n">NoiseModel</span><span class="o">.</span><span class="n">DECOHERENCE_KRAUS_OPERATOR</span><span class="p">,</span> <span class="n">GateType</span><span class="o">.</span><span class="n">PAULI_Y_GATE</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
<span class="c1"># 制定比特时，仅对指定的比特生效</span>
<span class="n">qvm</span><span class="o">.</span><span class="n">set_noise_model</span><span class="p">(</span><span class="n">NoiseModel</span><span class="o">.</span><span class="n">DECOHERENCE_KRAUS_OPERATOR</span><span class="p">,</span> <span class="n">GateType</span><span class="o">.</span><span class="n">Y_HALF_PI</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="c1"># 双门指定比特时, 需要同时指定两个比特，且对比特的顺序敏感</span>
<span class="n">qvm</span><span class="o">.</span><span class="n">set_noise_model</span><span class="p">(</span><span class="n">NoiseModel</span><span class="o">.</span><span class="n">DECOHERENCE_KRAUS_OPERATOR</span><span class="p">,</span> <span class="n">GateType</span><span class="o">.</span><span class="n">CZ_GATE</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="p">[[</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]]])</span>
<span class="c1">#可对线路中所有GateType加噪声</span>
<span class="n">qvm</span><span class="o">.</span><span class="n">set_noise_model</span><span class="p">(</span><span class="n">NoiseModel</span><span class="o">.</span><span class="n">BITFLIP_KRAUS_OPERATOR</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="n">qvm</span><span class="o">.</span><span class="n">set_noise_model</span><span class="p">(</span><span class="n">NoiseModel</span><span class="o">.</span><span class="n">DECOHERENCE_KRAUS_OPERATOR</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>
<span class="n">qvm</span><span class="o">.</span><span class="n">set_noise_model</span><span class="p">(</span><span class="n">NoiseModel</span><span class="o">.</span><span class="n">DAMPING_KRAUS_OPERATOR</span><span class="p">,</span> <span class="n">GateType</span><span class="o">.</span><span class="n">CNOT_GATE</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
</pre></div>
</div>
<p>含噪声虚拟机还支持设置带有角度的量子逻辑门的转转角度误差，其接口使用方式如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qvm</span><span class="o">.</span><span class="n">set_rotation_error</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>
</pre></div>
</div>
<p>即设置角度旋转误差为0.05。</p>
<p>设置测量误差,
其使用方法与上面的方法类似，只不过不需要指定量子逻辑门的类型</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qvm</span><span class="o">.</span><span class="n">set_measure_error</span><span class="p">(</span><span class="n">NoiseModel</span><span class="o">.</span><span class="n">DEPOLARIZING_KRAUS_OPERATOR</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<p>设置reset噪声：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p0</span> <span class="o">=</span> <span class="mf">0.9</span>
<span class="n">p1</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">qvm</span><span class="o">.</span><span class="n">set_reset_error</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">)</span>
</pre></div>
</div>
<p><span class="math notranslate nohighlight">\(p0 \)</span>p1<span class="math notranslate nohighlight">\(表示重置到\)</span>
|1⟩<span class="math notranslate nohighlight">\(的概率，未被重置的概率为\)</span> 1-p0-p1$</p>
<p>设置读取误差：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f0</span> <span class="o">=</span> <span class="mf">0.9</span>
<span class="n">f1</span> <span class="o">=</span> <span class="mf">0.85</span>
<span class="n">qvm</span><span class="o">.</span><span class="n">set_readout_error</span><span class="p">([[</span><span class="n">f0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">f0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f1</span><span class="p">]])</span>
</pre></div>
</div>
<p>表示在读取<span class="math notranslate nohighlight">\(q0\)</span>时0读为0的概率为0.9，读为1的概率为<span class="math notranslate nohighlight">\(1 - f0\)</span>，
1读为1的概率为0.85，读为0的概率为<span class="math notranslate nohighlight">\(1 - f1\)</span>。</p>
</section>
<section id="id27">
<h4>2.6.2.3 实例<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">qvm</span> <span class="o">=</span> <span class="n">NoiseQVM</span><span class="p">()</span>
    <span class="n">qvm</span><span class="o">.</span><span class="n">init_qvm</span><span class="p">()</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

    <span class="n">qvm</span><span class="o">.</span><span class="n">set_noise_model</span><span class="p">(</span><span class="n">NoiseModel</span><span class="o">.</span><span class="n">BITFLIP_KRAUS_OPERATOR</span><span class="p">,</span> <span class="n">GateType</span><span class="o">.</span><span class="n">PAULI_X_GATE</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
    <span class="n">qv0</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">qvm</span><span class="o">.</span><span class="n">set_noise_model</span><span class="p">(</span><span class="n">NoiseModel</span><span class="o">.</span><span class="n">DEPHASING_KRAUS_OPERATOR</span><span class="p">,</span> <span class="n">GateType</span><span class="o">.</span><span class="n">HADAMARD_GATE</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">qv0</span><span class="p">)</span>
    <span class="n">qves</span> <span class="o">=</span> <span class="p">[[</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]]]</span>
    <span class="n">qvm</span><span class="o">.</span><span class="n">set_noise_model</span><span class="p">(</span><span class="n">NoiseModel</span><span class="o">.</span><span class="n">DAMPING_KRAUS_OPERATOR</span><span class="p">,</span> <span class="n">GateType</span><span class="o">.</span><span class="n">CNOT_GATE</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">qves</span><span class="p">)</span>

    <span class="n">f0</span> <span class="o">=</span> <span class="mf">0.9</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="mf">0.85</span>
    <span class="n">qvm</span><span class="o">.</span><span class="n">set_readout_error</span><span class="p">([[</span><span class="n">f0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">f0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f1</span><span class="p">]])</span>
    <span class="n">qvm</span><span class="o">.</span><span class="n">set_rotation_error</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>

    <span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
    <span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">X</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> \
         <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> \
         <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> \
         <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> \
         <span class="o">&lt;&lt;</span> <span class="n">measure_all</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">run_with_configuration</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>运行结果：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;0000&#39;</span><span class="p">:</span> <span class="mi">347</span><span class="p">,</span> <span class="s1">&#39;0001&#39;</span><span class="p">:</span> <span class="mi">55</span><span class="p">,</span> <span class="s1">&#39;0010&#39;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="s1">&#39;0011&#39;</span><span class="p">:</span> <span class="mi">43</span><span class="p">,</span> <span class="s1">&#39;0100&#39;</span><span class="p">:</span> <span class="mi">41</span><span class="p">,</span> <span class="s1">&#39;0101&#39;</span><span class="p">:</span> <span class="mi">18</span><span class="p">,</span> <span class="s1">&#39;0110&#39;</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span> <span class="s1">&#39;0111&#39;</span><span class="p">:</span> <span class="mi">34</span><span class="p">,</span> <span class="s1">&#39;1000&#39;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="s1">&#39;1001&#39;</span><span class="p">:</span> <span class="mi">18</span><span class="p">,</span> <span class="s1">&#39;1010&#39;</span><span class="p">:</span> <span class="mi">18</span><span class="p">,</span> <span class="s1">&#39;1011&#39;</span><span class="p">:</span> <span class="mi">37</span><span class="p">,</span> <span class="s1">&#39;1100&#39;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span> <span class="s1">&#39;1101&#39;</span><span class="p">:</span> <span class="mi">49</span><span class="p">,</span> <span class="s1">&#39;1110&#39;</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span> <span class="s1">&#39;1111&#39;</span><span class="p">:</span> <span class="mi">167</span><span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id28">
<h3>2.6.3 单振幅量子虚拟机<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h3>
<p>目前我们可以通过量子计算的相关理论，用经典计算机实现模拟量子虚拟机。
量子虚拟机的模拟主要有全振幅与单振幅两种解决方案，其主要区别在于，全振幅一次模拟计算就能算出量子态的所有振幅，单振幅一次模拟计算只能计算出<span class="math notranslate nohighlight">\(2^n\)</span>个振幅中的一个。</p>
<p>然而全振幅模拟量子计算时间较长，计算量随量子比特数指数增长，
在现有硬件下，无法模拟超过49量子比特。通过单振幅量子虚拟机技术可以模拟超过49量子比特，同时模拟速度有较大提升，且算法的计算量不随量子比特数指数提升。</p>
<section id="id29">
<h4>2.6.3.1 使用介绍<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h4>
<p>其使用方式与前面介绍的量子虚拟机模块非常类似。主要接口有以下几种：</p>
<ul class="simple">
<li><p>run</p></li>
</ul>
<p>：输入参数为执行的量子程序，申请的量子比特，最大RANK，quickBB优化的最大运行时间</p>
<ul class="simple">
<li><p>pmeasure_bin_index</p></li>
</ul>
<p>：输入参数为二进制索引字符串，输出为该索引下的量子态。使用前需要调用run接口，如
pmeasure_bin_index(“0000000000”)
，同时保证字符串长度与测量的比特数相同</p>
<ul class="simple">
<li><p>pmeasure_dec_index</p></li>
</ul>
<p>：输入参数为十进制索引字符串，输出为该索引下的量子态。使用前需要调用run接口。如
pmeasure_dec_index(“1”)，同时保证索引大小不超过2的n次方(n为比特数)。</p>
<ul class="simple">
<li><p>get_prob_dict</p></li>
</ul>
<p>：输入参数为要执行的量子程序，以及要测量的量子比特。输出为对应量子比特的所有态结果。使用前需要调用run接口。需要注意的是该接口要求量子比特数为30个以内时使用。</p>
<ul class="simple">
<li><p>prob_run_dict</p></li>
</ul>
<p>：输入参数为要执行的量子程序，以及要测量的量子比特。输出为对应量子比特的所有态结果。需要注意的是该接口要求量子比特数为30个以内时使用。</p>
<p>首先通过 SingleAmpQVM
初始化一个单振幅量子虚拟机对象用于管理后续一系列行为</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">pi</span>

<span class="n">qvm</span> <span class="o">=</span> <span class="n">SingleAmpQVM</span><span class="p">()</span>
</pre></div>
</div>
<p>然后是量子程序的初始化、构建与装载过程：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qvm</span><span class="o">.</span><span class="n">init_qvm</span><span class="p">()</span>

<span class="n">qv</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">cv</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>

<span class="c1"># 构建量子程序</span>
<span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qv</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">qv</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">qv</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">qv</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qv</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RY</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RX</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RX</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CR</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pi</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CR</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">qv</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">pi</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RY</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RZ</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RX</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RZ</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CR</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">qv</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span> <span class="n">pi</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CR</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">pi</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RY</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RX</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RX</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CR</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span> <span class="n">qv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pi</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RY</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RY</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RZ</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CR</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">qv</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">pi</span><span class="p">)</span>
</pre></div>
</div>
<p>接口使用如下：</p>
<ul class="simple">
<li><p>pmeasure_bin_index，使用时需要结合 run 方法。用法示例：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qvm</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="n">qv</span><span class="p">)</span>
<span class="n">dec_result</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">pmeasure_bin_index</span><span class="p">(</span><span class="s2">&quot;0001000000&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;0001000000:&quot;</span><span class="p">,</span><span class="n">dec_result</span><span class="p">)</span>
</pre></div>
</div>
<p>输出结果如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0001000000</span> <span class="p">:</span>  <span class="mf">0.001953123603016138</span>
</pre></div>
</div>
<ul class="simple">
<li><p>pmeasure_dec_index，使用时需要结合 run 方法。用法示例：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qvm</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">qv</span><span class="p">)</span>
<span class="n">dec_result</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">pmeasure_dec_index</span><span class="p">(</span><span class="s2">&quot;2&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;2 : &quot;</span><span class="p">,</span><span class="n">dec_result</span><span class="p">)</span>
</pre></div>
</div>
<p>输出结果如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">2</span> <span class="p">:</span>  <span class="mf">0.001953123603016138</span>
</pre></div>
</div>
<ul class="simple">
<li><p>get_prob_dict,使用时需要结合run方法。用法示例：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qvm</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">qv</span><span class="p">)</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">get_prob_dict</span><span class="p">(</span><span class="n">qv</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>prob_run_dict接口是get_prob_dict和run的封装，用法示例：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">res_1</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">prob_run_dict</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">qv</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="id30">
<h3>2.6.4 部分振幅量子虚拟机<a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h3>
<p>目前用经典计算机模拟量子虚拟机的主流解决方案有全振幅与单振幅两种。除此之外，还有部分振幅量子虚拟机，该方案能在更低的硬件条件下，实现更高的模拟效率。</p>
<section id="id31">
<h4>2.6.4.1 使用介绍<a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h4>
<p>其使用方式与前面介绍的量子虚拟机模块非常类似，首先通过PartialAmpQVM
初始化一个部分振幅量子虚拟机对象用于管理后续一系列行为</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">pi</span>
<span class="n">machine</span> <span class="o">=</span> <span class="n">PartialAmpQVM</span><span class="p">()</span>
</pre></div>
</div>
<p>然后是量子程序的初始化、构建与装载过程，以QPanda2的
:ref:部分振幅示例程序来演示：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">machine</span><span class="o">.</span><span class="n">init_qvm</span><span class="p">()</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="c1"># 构建量子程序</span>
<span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
<span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">hadamard_circuit</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>\
     <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>\
     <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>\
     <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>\
     <span class="o">&lt;&lt;</span> <span class="n">RZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>\
     <span class="o">&lt;&lt;</span> <span class="n">RX</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>\
     <span class="o">&lt;&lt;</span> <span class="n">RX</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>\
     <span class="o">&lt;&lt;</span> <span class="n">RY</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>\
     <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>\
     <span class="o">&lt;&lt;</span> <span class="n">RZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>\
     <span class="o">&lt;&lt;</span> <span class="n">RZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>\
     <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>\
     <span class="o">&lt;&lt;</span> <span class="n">RY</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>\
     <span class="o">&lt;&lt;</span> <span class="n">RZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>\
     <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

<span class="n">machine</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">prog</span><span class="p">)</span>
</pre></div>
</div>
<p>部分接口使用如下：</p>
<ul class="simple">
<li><p>pmeasure_bin_index(string) ,使用示例</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">pmeasure_bin_index</span><span class="p">(</span><span class="s2">&quot;0000000000&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>输出结果如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">-</span><span class="mf">0.00647208746522665</span><span class="o">-</span><span class="mf">0.006472080945968628</span><span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>pmeasure_dec_index(string) ,使用示例</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">pmeasure_dec_index</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>输出结果如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">-</span><span class="mf">6.068964220062867e-10</span><span class="o">-</span><span class="mf">0.009152906015515327</span><span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>pmeasure_subset(state_index) ,使用示例</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">state_index</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">]</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">pmeasure_subset</span><span class="p">(</span><span class="n">state_index</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>输出结果如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.00647208746522665</span><span class="o">-</span><span class="mf">0.006472080945968628</span><span class="n">j</span><span class="p">),</span>
 <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mf">6.068964220062867e-10</span><span class="o">-</span><span class="mf">0.009152906015515327</span><span class="n">j</span><span class="p">),</span>
 <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mf">6.984919309616089e-10</span><span class="o">-</span><span class="mf">0.009152908809483051</span><span class="n">j</span><span class="p">)}</span>
</pre></div>
</div>
<p><em>警告</em></p>
<p>部分旧的接口，比如 get_qstate() 、 pmeasure(string) 、 pmeasure(string)</p>
<p>以及 get_prob_dict(qvec,string) 等已经被弃用了。</p>
</section>
</section>
<section id="id32">
<h3>2.6.5 张量网络量子虚拟机<a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h3>
<p>对于一个<span class="math notranslate nohighlight">\(N\)</span>个量子比特的自旋体系，对应的希尔伯特空间维数为<span class="math notranslate nohighlight">\(2^N\)</span>。</p>
<p>对于该复杂系统的状态演化，传统的全振幅模拟器将其看做一个有<span class="math notranslate nohighlight">\(2^N\)</span>个元素的一维向量。</p>
<p>然而从张量网络的角度来看，整个系统量子态的系数对应<span class="math notranslate nohighlight">\(2^N\)</span>维张量（即N阶张量，即有$
N
$个指标，每个指标的维数是2），量子操作算符的系数为<span class="math notranslate nohighlight">\(2^{2 N}\)</span>维张量（<span class="math notranslate nohighlight">\(2N\)</span>阶张量，即有<span class="math notranslate nohighlight">\(2N\)</span>个指标，每个指标的维数是2)，我们可以用如下图形来表示量子态：</p>
<figure class="align-default" id="id56">
<img alt="\_images/state.png" src="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/state.png" />
<figcaption>
<p><span class="caption-text">_images/state.png</span><a class="headerlink" href="#id56" title="永久链接至图片">¶</a></p>
</figcaption>
</figure>
<p>当量子系统的自旋个数增加时，量子态系数的个数随指数增加，称为指数墙问题，这一障碍限制了传统全振幅模拟器的最大模拟自旋数和模拟性能。</p>
<p>但是可通过张量网络处理这一问题，从而绕过指数墙障碍，在张量网络中，我们对量子系统的模拟，包括量子逻辑门操作和测量操作，均可以通过对于张量的缩并与分解来实现。矩阵乘积态是张量网络中最常用的表示形式，在多线性代数中称为张量列或TT（Tensor-Train），示意图如下。</p>
<figure class="align-default" id="id57">
<img alt="\_images/MPS.png" src="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/MPS.png" />
<figcaption>
<p><span class="caption-text">_images/MPS.png</span><a class="headerlink" href="#id57" title="永久链接至图片">¶</a></p>
</figcaption>
</figure>
<p>将量子态分解成等式右边的表示形式，对于量子线路中部分量子逻辑门操作，可以将全局问题转化为局部的张量处理问题，从而有效地降低了时间复杂度和空间复杂度。</p>
<section id="id33">
<h4>2.6.5.1 应用场景<a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h4>
<p>在量子电路的模拟方法中，选择合适的模拟后端非常重要，不同量子线路模拟器的适用场所如下：</p>
<ul class="simple">
<li><p>全振幅量子虚拟机</p></li>
</ul>
<p>：全振幅模拟器可以同时模拟和存储量子态的全部振幅，但受限于机器的内存条件，量子比特达到50位已是极限，适合低比特高深度的量子线路，比如低比特下的谷歌随机量子线路以及需要获取全部模拟结果的场景等。</p>
<ul class="simple">
<li><p>部分振幅量子虚拟机</p></li>
</ul>
<p>：部分振幅模拟器依赖于其他模拟器提供的低比特量子线路振幅模拟结果，能模拟更高的比特数量，但能模拟的深度降低，通常用于获取量子态振幅的部分子集模拟结果。</p>
<ul class="simple">
<li><p>单振幅量子虚拟机</p></li>
</ul>
<p>：单振幅模拟器能模拟更高的量子比特线路图，同时模拟的性能较高，不会随着量子比特数目增加呈指数型增长，但随着线路深度增加，模拟性能急剧下降，同时难以模拟多控制门也是其缺点，该模拟器适用于高比特、低深度的量子线路模拟，通常用于快速地模拟获得单个量子态振幅结果。</p>
<ul class="simple">
<li><p>张量网络量子虚拟机</p></li>
</ul>
<p>：张量网络模拟器与单振幅类似，与单振幅对比，可以模拟多控制门，同时在深度较高的线路模拟上存在性能优势。</p>
<ul class="simple">
<li><p>量子云虚拟机</p></li>
</ul>
<p>：量子云虚拟机可以将任务提交在远程高性能计算集群上运行，突破本地硬件性能限制，同时支持在真实的量子芯片上运行量子算法。</p>
</section>
<section id="id34">
<h4>2.6.5.2 使用介绍<a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h4>
<p>pyqpanda 中可以通过 MPSQVM
类实现用张量网络模拟量子电路。和许多其他模拟器的使用方法一样，都具有相同的量子虚拟机接口，比如下述简单的使用示例代码:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">pi</span>
<span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># 构建量子虚拟机</span>
<span class="n">qvm</span> <span class="o">=</span> <span class="n">MPSQVM</span><span class="p">()</span>

<span class="c1"># 初始化操作</span>
<span class="n">qvm</span><span class="o">.</span><span class="n">set_configure</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="n">qvm</span><span class="o">.</span><span class="n">init_qvm</span><span class="p">()</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="c1"># 构建量子程序</span>
<span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
<span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">hadamard_circuit</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

<span class="c1"># 量子程序运行100次，并返回测量结果</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">run_with_configuration</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="c1"># 打印量子态在量子程序多次运行结果中出现的次数</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<span class="n">qvm</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="id35">
<h4>2.6.5.3 完整示例代码<a class="headerlink" href="#id35" title="永久链接至标题">¶</a></h4>
<p>以下示例展示了张量网络模拟器计算部分接口的使用方式</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">pi</span>
<span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">qvm</span> <span class="o">=</span> <span class="n">MPSQVM</span><span class="p">()</span>
<span class="n">qvm</span><span class="o">.</span><span class="n">set_configure</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="n">qvm</span><span class="o">.</span><span class="n">init_qvm</span><span class="p">()</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
<span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">hadamard_circuit</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RY</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RX</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RX</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CR</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pi</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CR</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">pi</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RY</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

<span class="c1"># Monte Carlo采样模拟接口</span>
<span class="n">result0</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">run_with_configuration</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="c1"># 概率测量接口</span>
<span class="n">result1</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">prob_run_dict</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">result0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result1</span><span class="p">)</span>

<span class="n">qvm</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
</pre></div>
</div>
<p>上述代码中run_with_configuration 与 prob_run_dict 接口分别用于Monte
Carlo采样模拟和概率测量，他们分别输出模拟采样的结果和对应振幅的概率，上述程序的计算结果如下</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Monte Carlo 采样模拟结果</span>
<span class="p">{</span><span class="s1">&#39;0000000000&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
 <span class="s1">&#39;0000000001&#39;</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span>
 <span class="s1">&#39;0000000010&#39;</span><span class="p">:</span> <span class="mi">13</span><span class="p">,</span>
 <span class="s1">&#39;0000000011&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
 <span class="s1">&#39;0000000100&#39;</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span>
 <span class="s1">&#39;0000000101&#39;</span><span class="p">:</span> <span class="mi">14</span><span class="p">,</span>
 <span class="s1">&#39;0000000110&#39;</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span>
 <span class="s1">&#39;0000000111&#39;</span><span class="p">:</span> <span class="mi">16</span><span class="p">}</span>

<span class="c1"># 概率测量结果</span>
<span class="p">{</span><span class="s1">&#39;000&#39;</span><span class="p">:</span> <span class="mf">0.12499999999999194</span><span class="p">,</span>
 <span class="s1">&#39;001&#39;</span><span class="p">:</span> <span class="mf">0.12499999999999185</span><span class="p">,</span>
 <span class="s1">&#39;010&#39;</span><span class="p">:</span> <span class="mf">0.12499999999999194</span><span class="p">,</span>
 <span class="s1">&#39;011&#39;</span><span class="p">:</span> <span class="mf">0.124999999999992</span><span class="p">,</span>
 <span class="s1">&#39;100&#39;</span><span class="p">:</span> <span class="mf">0.12499999999999198</span><span class="p">,</span>
 <span class="s1">&#39;101&#39;</span><span class="p">:</span> <span class="mf">0.12499999999999194</span><span class="p">,</span>
 <span class="s1">&#39;110&#39;</span><span class="p">:</span> <span class="mf">0.12499999999999198</span><span class="p">,</span>
 <span class="s1">&#39;111&#39;</span><span class="p">:</span> <span class="mf">0.12499999999999208</span><span class="p">}</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="id36">
<h2><strong>2.7 量子比特池</strong><a class="headerlink" href="#id36" title="永久链接至标题">¶</a></h2>
<section id="id37">
<h3>2.7.1 简介<a class="headerlink" href="#id37" title="永久链接至标题">¶</a></h3>
<p>QPanda之前版本中量子比特和经典寄存器都是通过虚拟机进行申请，管理，控制。
现在提供独立于虚拟机的方法，即量子比特、经典寄存器不通过虚拟机管理，可以由提供的比特池直接申请、释放。
为了更好的使用量子比特和经典寄存器，我们进一步支持以物理地址代表相应比特使用。</p>
</section>
<section id="id38">
<h3>2.7.2 接口说明<a class="headerlink" href="#id38" title="永久链接至标题">¶</a></h3>
<p>量子比特池：</p>
<ul class="simple">
<li><p>OriginQubitPool 获取单例的量子比特池， 通过该池对象申请释放量子比特</p></li>
<li><p>get_capacity 获取最大容量</p></li>
<li><p>set_capacity 设置容量</p></li>
<li><p>get_qubit_by_addr 通过物理地址获取量子比特</p></li>
</ul>
<p>经典寄存器池：</p>
<ul class="simple">
<li><p>OriginCMem 获取单例的经典寄存器池，通过该池对象申请释放经典寄存器</p></li>
<li><p>get_capacity 获取最大容量</p></li>
<li><p>set_capacity 设置容量</p></li>
<li><p>get_cbit_by_addr 通过物理地址获取量子比特</p></li>
</ul>
<p>由于申请释放方法均和虚拟机提供的方法相同。在<a class="reference external" href="#quantummachine">量子虚拟机</a>中有详细介绍。
同时对于量子比特和经典寄存器的使用，现在也可以直接通过对应比特的地址传参。</p>
<p>例如 : H(1) 可以理解在物理地址为1的量子比特上作用H门。 Measure(1, 1)
可以理解在物理地址为1的量子比特施加Meausre测量，并将结果保存在地址为1的经典寄存器上。</p>
</section>
<section id="id39">
<h3>2.7.3 实例<a class="headerlink" href="#id39" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">pi</span>
<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># 量子比特可以和虚拟机 脱离关系，获取对应池的单例，这里和QPanda不同，构建的对象就是单例的池</span>
    <span class="n">qpool</span> <span class="o">=</span> <span class="n">OriginQubitPool</span><span class="p">()</span>
    <span class="n">qpool_1</span> <span class="o">=</span> <span class="n">OriginQubitPool</span><span class="p">()</span>
    <span class="n">cmem</span> <span class="o">=</span> <span class="n">OriginCMem</span><span class="p">()</span>

    <span class="c1"># 获取量子比特池容量</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;get_capacity : &quot;</span><span class="p">,</span> <span class="n">qpool</span><span class="o">.</span><span class="n">get_capacity</span><span class="p">())</span>
    <span class="c1"># 设置量子比特池容量</span>
    <span class="n">qpool</span><span class="o">.</span><span class="n">set_capacity</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;qpool get_capacity : &quot;</span><span class="p">,</span> <span class="n">qpool</span><span class="o">.</span><span class="n">get_capacity</span><span class="p">())</span>

    <span class="c1">#由于获取量子比特池是单例对象，上面设置容量为20，这里qool_1 获取容量也会为20</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;qpool_1 get_capacity : &quot;</span><span class="p">,</span> <span class="n">qpool_1</span><span class="o">.</span><span class="n">get_capacity</span><span class="p">())</span>

    <span class="c1"># 通过比特池申请比特，由于是单例模式，要保证申请的比特数量不超过最大容量</span>
    <span class="n">qv</span> <span class="o">=</span> <span class="n">qpool</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
    <span class="n">cv</span> <span class="o">=</span> <span class="n">cmem</span><span class="o">.</span><span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

    <span class="c1"># 构建虚拟机</span>
    <span class="n">qvm</span> <span class="o">=</span> <span class="n">CPUQVM</span><span class="p">()</span>
    <span class="n">qvm</span><span class="o">.</span><span class="n">init_qvm</span><span class="p">()</span>
    <span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
    <span class="c1"># 直接使用物理地址作为量子比特信息入参</span>
    <span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>\
        <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>\
        <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>\
        <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>\
        <span class="o">&lt;&lt;</span> <span class="n">X</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>\
        <span class="o">&lt;&lt;</span> <span class="n">X1</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>\
        <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>\
        <span class="o">&lt;&lt;</span> <span class="n">RX</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>\
        <span class="o">&lt;&lt;</span> <span class="n">CR</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>\
        <span class="o">&lt;&lt;</span> <span class="n">SWAP</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>\
        <span class="o">&lt;&lt;</span> <span class="n">CU</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">5</span><span class="p">)</span>\
        <span class="o">&lt;&lt;</span> <span class="n">U4</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">,</span> <span class="mf">2.4</span><span class="p">)</span>\
        <span class="o">&lt;&lt;</span> <span class="n">BARRIER</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>\
        <span class="o">&lt;&lt;</span> <span class="n">BARRIER</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1">#print(prog)</span>

    <span class="c1"># 测量方法也可以使用比特物理地址</span>
    <span class="n">res_0</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">prob_run_dict</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="p">[</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span> <span class="p">])</span>
    <span class="c1">#res_1 = qvm.prob_run_dict(prog, qv)  #同等上述方法</span>
    <span class="c1">#print(res_0)</span>

    <span class="c1"># 同样经典比特地址也可以作为经典比特信息入参</span>
    <span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>\
        <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>\
        <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>\
        <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>\
        <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>\
        <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>


    <span class="c1"># 使用经典比特地址入参</span>
    <span class="n">res_2</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">run_with_configuration</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="p">[</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span> <span class="p">],</span> <span class="mi">5000</span><span class="p">)</span>
    <span class="c1"># res_3 = qvm.run_with_configuration(prog, cv, 5000) #同等上述方法</span>
    <span class="c1">#print(res_2)</span>

    <span class="n">qvm</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>


    <span class="c1"># 同时我们还可以再次利用这里申请的qv，避免多次使用虚拟机多次申请比特的问题发生</span>
    <span class="n">qvm_noise</span> <span class="o">=</span> <span class="n">NoiseQVM</span><span class="p">()</span>
    <span class="n">qvm_noise</span><span class="o">.</span><span class="n">init_qvm</span><span class="p">()</span>
    <span class="n">res_4</span> <span class="o">=</span> <span class="n">qvm_noise</span><span class="o">.</span><span class="n">run_with_configuration</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="p">[</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span> <span class="p">],</span> <span class="mi">5000</span><span class="p">)</span>
    <span class="n">qvm_noise</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
</pre></div>
</div>
<p>运行结果：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">get_capacity</span> <span class="p">:</span>  <span class="mi">29</span>
<span class="n">qpool</span> <span class="n">get_capacity</span> <span class="p">:</span>  <span class="mi">20</span>
<span class="n">qpool_1</span> <span class="n">get_capacity</span> <span class="p">:</span>  <span class="mi">20</span>
</pre></div>
</div>
</section>
</section>
<section id="id40">
<h2><strong>2.8 量子测量</strong><a class="headerlink" href="#id40" title="永久链接至标题">¶</a></h2>
<p>量子测量是指通过外界对量子系统进行干扰来获取需要的信息，测量门使用的是蒙特卡洛方法的测量。在量子线路中用如下图标表示：</p>
<figure class="align-default" id="id58">
<img alt="*images/QGate*\ measure.png" src="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/QGate_measure.png" />
<figcaption>
<p><span class="caption-text"><em>images/QGate</em>measure.png</span><a class="headerlink" href="#id58" title="永久链接至图片">¶</a></p>
</figcaption>
</figure>
<section id="id41">
<h3>2.8.1 接口介绍<a class="headerlink" href="#id41" title="永久链接至标题">¶</a></h3>
<p>本章主要介绍获得量子测量对象、根据配置运行含有量子测量的量子程序、快速测量。</p>
<p>在量子程序中我们需要对某个量子比特做测量操作，并把测量结果存储到经典寄存器上，可以通过下面的方式获得一个测量对象：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">measure</span> <span class="o">=</span> <span class="n">Measure</span><span class="p">(</span><span class="n">qubit</span><span class="p">,</span> <span class="n">cbit</span><span class="p">);</span>
</pre></div>
</div>
<p>可以看到Measure接两个参数，第一个是测量比特，第二个是经典寄存器。</p>
<p>如果想测量所有的量子比特并将其存储到对应的经典寄存器上， 可以如下操作：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>measureprog = measure_all(qubits， cbits);
</pre></div>
</div>
<p>其中qubits的类型是 QVec ， cbits的类型是ClassicalCondition list。</p>
<p><em>注解：</em></p>
<p>measure_all 的返回值类型是 QProg。</p>
<p>在得到含有量子测量的程序后，我们可以调用directly_run 或
run_with_configuration 来得到量子程序的测量结果。</p>
<p>directly_run 的功能是运行量子程序并返回运行的结果，使用方法如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
<span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>\
     <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>\
     <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>\
     <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>\
     <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cbits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">directly_run</span><span class="p">(</span><span class="n">prog</span><span class="p">)</span>
</pre></div>
</div>
<p>run_with_configuration 的功能是统计量子程序多次运行的测量结果，
使用方法如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
<span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>\
     <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>\
     <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>\
     <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>\
     <span class="o">&lt;&lt;</span> <span class="n">measure_all</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">cbits</span><span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">run_with_configuration</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">cbits</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
</pre></div>
</div>
<p>其中第一个参数是量子程序，第二个参数是ClassicalCondition list，
第三个参数是运行的次数。</p>
</section>
<section id="id42">
<h3>2.8.2 实例<a class="headerlink" href="#id42" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">init</span><span class="p">(</span><span class="n">QMachineType</span><span class="o">.</span><span class="n">CPU</span><span class="p">)</span>
    <span class="n">qubits</span> <span class="o">=</span> <span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">cbits</span> <span class="o">=</span> <span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

    <span class="c1"># 构建量子程序</span>
    <span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
    <span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>\
         <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>\
         <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>\
         <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>\
         <span class="o">&lt;&lt;</span> <span class="n">measure_all</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">cbits</span><span class="p">)</span>

    <span class="c1"># 量子程序运行1000次，并返回测量结果</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">run_with_configuration</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">cbits</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>

    <span class="c1"># 打印测量结果</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="n">finalize</span><span class="p">()</span>
</pre></div>
</div>
<p>运行结果：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;0000&#39;</span><span class="p">:</span> <span class="mi">59</span><span class="p">,</span> <span class="s1">&#39;0001&#39;</span><span class="p">:</span> <span class="mi">69</span><span class="p">,</span> <span class="s1">&#39;0010&#39;</span><span class="p">:</span> <span class="mi">52</span><span class="p">,</span> <span class="s1">&#39;0011&#39;</span><span class="p">:</span> <span class="mi">62</span><span class="p">,</span>
<span class="s1">&#39;0100&#39;</span><span class="p">:</span> <span class="mi">63</span><span class="p">,</span> <span class="s1">&#39;0101&#39;</span><span class="p">:</span> <span class="mi">67</span><span class="p">,</span> <span class="s1">&#39;0110&#39;</span><span class="p">:</span> <span class="mi">79</span><span class="p">,</span> <span class="s1">&#39;0111&#39;</span><span class="p">:</span> <span class="mi">47</span><span class="p">,</span>
<span class="s1">&#39;1000&#39;</span><span class="p">:</span> <span class="mi">73</span><span class="p">,</span> <span class="s1">&#39;1001&#39;</span><span class="p">:</span> <span class="mi">59</span><span class="p">,</span> <span class="s1">&#39;1010&#39;</span><span class="p">:</span> <span class="mi">72</span><span class="p">,</span> <span class="s1">&#39;1011&#39;</span><span class="p">:</span> <span class="mi">60</span><span class="p">,</span>
<span class="s1">&#39;1100&#39;</span><span class="p">:</span> <span class="mi">61</span><span class="p">,</span> <span class="s1">&#39;1101&#39;</span><span class="p">:</span> <span class="mi">71</span><span class="p">,</span> <span class="s1">&#39;1110&#39;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="s1">&#39;1111&#39;</span><span class="p">:</span> <span class="mi">56</span><span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id43">
<h2><strong>2.9 概率测量</strong><a class="headerlink" href="#id43" title="永久链接至标题">¶</a></h2>
<p>概率测量是指获得目标量子比特的振幅，目标量子比特可以是一个量子比特也可以是多个量子比特的集合。
在QPanda2中概率测量又称为PMeasure
。概率测量和<a class="reference external" href="#measure">量子测量</a>是完全不同的过程，Measure是执行了一次测量，并返回一个确定的0/1结果，并且改变了量子态。</p>
<section id="id44">
<h3>2.9.1 接口介绍<a class="headerlink" href="#id44" title="永久链接至标题">¶</a></h3>
<p>QPanda2提供了三种获得PMeasure结果的方式，其中有 prob_run_list 、
prob_run_tuple_list 、 prob_run_dict。</p>
<ul class="simple">
<li><p>prob_run_list ： 获得目标量子比特的概率测量结果列表。</p></li>
<li><p>prob_run_tuple_list：</p></li>
</ul>
<p>获得目标量子比特的概率测量结果，为字典类型，其对应的下标为十进制。</p>
<ul class="simple">
<li><p>prob_run_dict ：</p></li>
</ul>
<p>获得目标量子比特的概率测量结果，为字典类型，其对应的下标为二进制。</p>
<p>这三个函数的使用方式是一样的，下面就以 prob_run_dict
为例介绍，使用方式如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
<span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>\
     <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>\
     <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>\
     <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">prob_run_dict</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">qubits</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>第一个参数是量子程序， 第二个参数是QVec它指定了我们关注的量子比特。
第三个参的值为-1时，获取所有的概率测量结果，大于0时表示获取最大的前几个数。</p>
</section>
<section id="id45">
<h3>2.9.2 实例<a class="headerlink" href="#id45" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">init</span><span class="p">(</span><span class="n">QMachineType</span><span class="o">.</span><span class="n">CPU</span><span class="p">)</span>
    <span class="n">qubits</span> <span class="o">=</span> <span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">cbits</span> <span class="o">=</span> <span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
    <span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>\
        <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;prob_run_dict: &quot;</span><span class="p">)</span>
    <span class="n">result1</span> <span class="o">=</span> <span class="n">prob_run_dict</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">qubits</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">result1</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;prob_run_tuple_list: &quot;</span><span class="p">)</span>
    <span class="n">result2</span> <span class="o">=</span> <span class="n">prob_run_tuple_list</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">qubits</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">result2</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;prob_run_list: &quot;</span><span class="p">)</span>
    <span class="n">result3</span> <span class="o">=</span> <span class="n">prob_run_list</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">qubits</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">result3</span><span class="p">)</span>

    <span class="n">finalize</span><span class="p">()</span>
</pre></div>
</div>
<p>运行结果：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prob_run_dict</span><span class="p">:</span>
<span class="p">{</span><span class="s1">&#39;00&#39;</span><span class="p">:</span> <span class="mf">0.4999999999999999</span><span class="p">,</span> <span class="s1">&#39;01&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;10&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;11&#39;</span><span class="p">:</span> <span class="mf">0.4999999999999999</span><span class="p">}</span>
<span class="n">prob_run_tuple_list</span><span class="p">:</span>
<span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.4999999999999999</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mf">0.4999999999999999</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)]</span>
<span class="n">prob_run_list</span><span class="p">:</span>
<span class="p">[</span><span class="mf">0.4999999999999999</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.4999999999999999</span><span class="p">]</span>
</pre></div>
</div>
<p><em>注解：</em></p>
<p>概率测量 不支持噪声虚拟机</p>
</section>
</section>
<section id="id46">
<h2><strong>2.10 本源量子云服务</strong><a class="headerlink" href="#id46" title="永久链接至标题">¶</a></h2>
<p>在复杂的量子线路模拟中有必要借助于高性能计算机集群或真实的量子计算机，用云计算的方式替代本地计算，在一定程度上减轻用户的计算成本，获得更好的计算体验。</p>
<p>本源量子量子云平台经由调度服务器向部署在远程的量子计算机或计算集群提交任务，并接收返回的结果，流程如下图所示。</p>
<figure class="align-default" id="id59">
<img alt="\_images/qcloud.png" src="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/qcloud.png" />
<figcaption>
<p><span class="caption-text">_images/qcloud.png</span><a class="headerlink" href="#id59" title="永久链接至图片">¶</a></p>
</figcaption>
</figure>
<p>pyqpanda封装了量子云虚拟机，可以向本源量子的计算服务器集群或量子真实芯片发送计算指令，并获取计算结果，在使用下文介绍的各种虚拟机之前，需要确保已开通对应的虚拟机产品。</p>
<figure class="align-default" id="id60">
<img alt="\_images/real.png" src="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/real.png" />
<figcaption>
<p><span class="caption-text">_images/real.png</span><a class="headerlink" href="#id60" title="永久链接至图片">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id61">
<img alt="\_images/cloud.png" src="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/cloud.png" />
<figcaption>
<p><span class="caption-text">_images/cloud.png</span><a class="headerlink" href="#id61" title="永久链接至图片">¶</a></p>
</figcaption>
</figure>
<section id="id47">
<h3>2.10.1 真实芯片计算服务<a class="headerlink" href="#id47" title="永久链接至标题">¶</a></h3>
<section id="id48">
<h4>2.10.1.1 本源悟源超导芯片<a class="headerlink" href="#id48" title="永久链接至标题">¶</a></h4>
<p>本源悟源
是2020年9月12日本源量子自主研发的超导量子计算机（搭载6比特超导量子处理器夸父
KF
C6-130）。得益于本源超导量子计算云平台，量子计算机可以走出实验室，为众多潜在行业提供探索量子计算的基础条件，推进量子计算产业落地与工程化发展，真正为人类社会服务。</p>
<p>超导量子计算云平台作为连接用户和量子计算系统之间的桥梁，在用户向量子系统发起计算任务到量子系统完成计算任务后返回计算结果过程中，发挥着重要的协调中转作用。</p>
<p>本源悟源的 芯片拓扑结构图 如下：</p>
<figure class="align-default" id="id62">
<img alt="\_images/tuopu.png" src="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/tuopu.png" />
<figcaption>
<p><span class="caption-text">_images/tuopu.png</span><a class="headerlink" href="#id62" title="永久链接至图片">¶</a></p>
</figcaption>
</figure>
<p>对应的 芯片参数 信息如下图：</p>
<figure class="align-default" id="id63">
<img alt="\_images/param.png" src="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/param.png" />
<figcaption>
<p><span class="caption-text">_images/param.png</span><a class="headerlink" href="#id63" title="永久链接至图片">¶</a></p>
</figcaption>
</figure>
<p>接口介绍如下：</p>
<ul class="simple">
<li><p>1.蒙特卡洛测量接口： real_chip_measure ,使用示例如下：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">PI</span> <span class="o">=</span> <span class="mf">3.1416</span>

<span class="c1"># 通过QCloud()创建量子云虚拟机</span>
<span class="n">QCM</span> <span class="o">=</span> <span class="n">QCloud</span><span class="p">()</span>

<span class="c1"># 通过传入当前用户的token来初始化</span>
<span class="n">QCM</span><span class="o">.</span><span class="n">init_qvm</span><span class="p">(</span><span class="s2">&quot;E02BB115D5294012AA88D4BE82603984&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">QCM</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">QCM</span><span class="o">.</span><span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># 构建量子程序</span>
<span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
<span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">hadamard_circuit</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RX</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">PI</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RX</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">PI</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RX</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">PI</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="c1"># 调用真实芯片计算接口，至少需要量子程序和测量次数两个参数，后面的三个默认参数依次为芯片类型，是否开启线路映射与线路优化功能。</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">QCM</span><span class="o">.</span><span class="n">real_chip_measure</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">real_chip_type</span><span class="o">.</span><span class="n">origin_wuyuan_d4</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<span class="n">QCM</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
</pre></div>
</div>
<p>上述过程需要注意的是， init 需要用户传入量子云平台用户验证标识 token
，可以从本源量子云平台个人信息下获取，具体见下方截图。</p>
<figure class="align-default" id="id64">
<img alt="\_images/token.png" src="https://pyqpanda-toturial.readthedocs.io/zh/latest/_images/token.png" />
<figcaption>
<p><span class="caption-text">_images/token.png</span><a class="headerlink" href="#id64" title="永久链接至图片">¶</a></p>
</figcaption>
</figure>
<p>输出结果如下,左侧是量子态的二进制表示，右边表示测量次数对应的概率：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;00&#39;</span><span class="p">:</span> <span class="mf">0.24987328940699444</span><span class="p">,</span> <span class="s1">&#39;01&#39;</span><span class="p">:</span> <span class="mf">0.2524075012671059</span><span class="p">,</span> <span class="s1">&#39;10&#39;</span><span class="p">:</span> <span class="mf">0.2519006588950836</span><span class="p">,</span> <span class="s1">&#39;11&#39;</span><span class="p">:</span> <span class="mf">0.24581855043081605</span><span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>2.获取量子态qst层析结果接口： get_state_tomography_density</p></li>
</ul>
<p>,使用示例如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">PI</span> <span class="o">=</span> <span class="mf">3.1416</span>

<span class="c1"># 通过QCloud()创建量子云虚拟机</span>
<span class="n">QCM</span> <span class="o">=</span> <span class="n">QCloud</span><span class="p">()</span>

<span class="c1"># 通过传入当前用户的token来初始化</span>
<span class="n">QCM</span><span class="o">.</span><span class="n">init_qvm</span><span class="p">(</span><span class="s2">&quot;E02BB115D5294012AA88D4BE82603984&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">QCM</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">QCM</span><span class="o">.</span><span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># 构建量子程序</span>
<span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
<span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">hadamard_circuit</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RX</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">PI</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RX</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">PI</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RX</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">PI</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="c1"># 调用真实芯片计算接口，至少需要量子程序和测量次数两个参数，后面的三个默认参数依次为芯片类型，是否开启线路映射与线路优化功能。</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">QCM</span><span class="o">.</span><span class="n">get_state_tomography_density</span><span class="p">(</span> <span class="n">prog</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">real_chip_type</span><span class="o">.</span><span class="n">origin_wuyuan_d4</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<span class="n">QCM</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
</pre></div>
</div>
<p>输出结果如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[(</span><span class="mf">0.26001013684744045</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.23492143943233657</span><span class="o">+</span><span class="mf">0.000760263558033436</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.01267105930055755</span><span class="o">+</span><span class="mf">0.002280790674100364</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.003547896604156095</span><span class="o">-</span><span class="mf">0.003294475418144968</span><span class="n">j</span><span class="p">)],</span>
<span class="p">[(</span><span class="mf">0.23492143943233657</span><span class="o">-</span><span class="mf">0.000760263558033436</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.250886974151039</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.00937658388241254</span><span class="o">+</span><span class="mf">0.003547896604156081</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.009883426254434847</span><span class="o">-</span><span class="mf">0.0025342118601114905</span><span class="n">j</span><span class="p">)],</span>
<span class="p">[(</span><span class="mf">0.01267105930055755</span><span class="o">-</span><span class="mf">0.002280790674100364</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.00937658388241254</span><span class="o">-</span><span class="mf">0.003547896604156081</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.2412569690826153</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.2240243284338571</span><span class="o">-</span><span class="mf">0.009123162696401413</span><span class="n">j</span><span class="p">)],</span>
<span class="p">[(</span><span class="o">-</span><span class="mf">0.003547896604156095</span><span class="o">+</span><span class="mf">0.003294475418144968</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.009883426254434847</span><span class="o">+</span><span class="mf">0.0025342118601114905</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.2240243284338571</span><span class="o">+</span><span class="mf">0.009123162696401413</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.24784591991890528</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)]]</span>
</pre></div>
</div>
<ul class="simple">
<li><p>3.获取量子态保真度接口： get_state_fidelity ,使用示例如下：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">PI</span> <span class="o">=</span> <span class="mf">3.1416</span>

<span class="c1"># 通过QCloud()创建量子云虚拟机</span>
<span class="n">QCM</span> <span class="o">=</span> <span class="n">QCloud</span><span class="p">()</span>

<span class="c1"># 通过传入当前用户的token来初始化</span>
<span class="n">QCM</span><span class="o">.</span><span class="n">init_qvm</span><span class="p">(</span><span class="s2">&quot;E02BB115D5294012AA88D4BE82603984&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">QCM</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">QCM</span><span class="o">.</span><span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># 构建量子程序</span>
<span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
<span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">hadamard_circuit</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RX</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">PI</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RX</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">PI</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">RX</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">PI</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="c1"># 调用真实芯片计算接口，至少需要量子程序和测量次数两个参数，后面的三个默认参数依次为芯片类型，是否开启线路映射与线路优化功能。</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">QCM</span><span class="o">.</span><span class="n">get_state_fidelity</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">real_chip_type</span><span class="o">.</span><span class="n">origin_wuyuan_d4</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<span class="n">QCM</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
</pre></div>
</div>
<p>输出结果如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">0.942748</span>
</pre></div>
</div>
<p>在使用本源悟源真实芯片测量操作时，经常会遇到各种错误，下面给出部分错误信息，可以根据抛出的错误异常信息进行对号入座。</p>
<ul class="simple">
<li><p>server connection failed ：该异常表示服务器宕机或与服务器连接失败。</p></li>
<li><p>api key error</p></li>
</ul>
<p>：该异常表示用户的API-Key参数异常，请去官网确认个人资料的信息。</p>
<ul class="simple">
<li><p>un-activate products or lack of computing power</p></li>
</ul>
<p>：该异常表示用户未开通该产品或算力不足。</p>
<ul class="simple">
<li><p>build system error ：该异常表示编译系统运行出错。</p></li>
<li><p>exceeding maximum timing sequence ：该异常表示量子程序时序过长。</p></li>
<li><p>unknown task status ：其他任务状态异常的情况。</p></li>
</ul>
<p><em>注解：</em></p>
<ol class="arabic simple">
<li><p>使用对应的计算接口时，需要确认当前用户已经开通了该产品，否则可能会导致提交计算任务失败。</p></li>
<li><p>在噪声模拟时，退相干的单门噪声和双门参数参数分别有3个，不同于其他噪声</p></li>
<li><p>本源悟源测量操作支持的测量次数范围在1000至10000之间，且目前仅支持6及以下量子比特的量子线路模拟，未来会加入其他的量子芯片，敬请期待。</p></li>
<li><p>在使用时遇到任何问题，请给我们提交用户反馈
，我们看到后会尽快解决你的问题</p></li>
</ol>
</section>
</section>
<section id="id49">
<h3>2.10.2 本源高性能计算集群云服务<a class="headerlink" href="#id49" title="永久链接至标题">¶</a></h3>
<p>本源量子的高性能计算集群提供多种功能强大的虚拟机计算后端，适用于不同情况下的量子线路模拟需求，完整示例程序介绍如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># 通过QCloud()创建量子云虚拟机</span>
<span class="n">QCM</span> <span class="o">=</span> <span class="n">QCloud</span><span class="p">()</span>

<span class="c1"># 通过传入当前用户的token来初始化</span>
<span class="n">QCM</span><span class="o">.</span><span class="n">init_qvm</span><span class="p">(</span><span class="s2">&quot;3B1AC640AAC248C6A7EE4E8D8537370D&quot;</span><span class="p">)</span>

<span class="n">qlist</span> <span class="o">=</span> <span class="n">QCM</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="n">clist</span> <span class="o">=</span> <span class="n">QCM</span><span class="o">.</span><span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># 构建量子程序，可以手动输入，也可以来自OriginIR或QASM语法文件等</span>
<span class="n">measure_prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
<span class="n">measure_prog</span> <span class="o">&lt;&lt;</span> <span class="n">hadamard_circuit</span><span class="p">(</span><span class="n">qlist</span><span class="p">)</span>\
             <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qlist</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>\
             <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">clist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>\
             <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">clist</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="n">pmeasure_prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
<span class="n">pmeasure_prog</span> <span class="o">&lt;&lt;</span> <span class="n">hadamard_circuit</span><span class="p">(</span><span class="n">qlist</span><span class="p">)</span>\
              <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qlist</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>\
              <span class="o">&lt;&lt;</span> <span class="n">RX</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>\
              <span class="o">&lt;&lt;</span> <span class="n">RX</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>\

<span class="c1"># 调用全振幅蒙特卡洛测量操作计算接口，需要量子程序和测量次数两个参数</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">QCM</span><span class="o">.</span><span class="n">full_amplitude_measure</span><span class="p">(</span><span class="n">measure_prog</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<section id="id50">
<h4>2.10.2.1 全振幅模拟云计算<a class="headerlink" href="#id50" title="永久链接至标题">¶</a></h4>
<p>接口介绍如下：</p>
<ul class="simple">
<li><p>full_amplitude_measure(全振幅蒙特卡洛测量操作) ：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result0</span> <span class="o">=</span> <span class="n">QCM</span><span class="o">.</span><span class="n">full_amplitude_measure</span><span class="p">(</span><span class="n">measure_prog</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result0</span><span class="p">)</span>
</pre></div>
</div>
<p>​
需要传入的第二个参数是测量次数，输出结果如下,左侧是量子态的二进制表示，右边表示测量次数对应的概率：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;00&#39;</span><span class="p">:</span> <span class="mf">0.25</span><span class="p">,</span>
 <span class="s1">&#39;01&#39;</span><span class="p">:</span> <span class="mf">0.28</span><span class="p">,</span>
 <span class="s1">&#39;10&#39;</span><span class="p">:</span> <span class="mf">0.22</span><span class="p">,</span>
 <span class="s1">&#39;11&#39;</span><span class="p">:</span> <span class="mf">0.25</span><span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>full_amplitude_pmeasure(全振幅概率测量操作) ：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result1</span> <span class="o">=</span> <span class="n">QCM</span><span class="o">.</span><span class="n">full_amplitude_pmeasure</span><span class="p">(</span><span class="n">pmeasure_prog</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result1</span><span class="p">)</span>
</pre></div>
</div>
<p>​
需要传入的第二个参数是测量的比特，输出结果如下,左侧是量子态的二进制表示，右边表示测量对应的概率：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;000&#39;</span><span class="p">:</span> <span class="mf">0.125</span><span class="p">,</span>
 <span class="s1">&#39;001&#39;</span><span class="p">:</span> <span class="mf">0.125</span><span class="p">,</span>
 <span class="s1">&#39;010&#39;</span><span class="p">:</span> <span class="mf">0.125</span><span class="p">,</span>
 <span class="s1">&#39;011&#39;</span><span class="p">:</span> <span class="mf">0.125</span><span class="p">,</span>
 <span class="s1">&#39;100&#39;</span><span class="p">:</span> <span class="mf">0.125</span><span class="p">,</span>
 <span class="s1">&#39;110&#39;</span><span class="p">:</span> <span class="mf">0.125</span><span class="p">,</span>
 <span class="s1">&#39;111&#39;</span><span class="p">:</span> <span class="mf">0.125</span><span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id51">
<h4>2.10.2.2 部分振幅模拟云计算<a class="headerlink" href="#id51" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li><p>partial_amplitude_pmeasure(部分振幅概率测量操作) ：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result2</span> <span class="o">=</span> <span class="n">QCM</span><span class="o">.</span><span class="n">partial_amplitude_pmeasure</span><span class="p">(</span><span class="n">pmeasure_prog</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result2</span><span class="p">)</span>
</pre></div>
</div>
<p>​
需要传入的第二个参数是测量的量子态振幅的十进制表示，输出结果如下,左侧是量子态振幅的十进制表示，右边表示复数形式的振幅值：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.08838832192122936</span><span class="o">-</span><span class="mf">0.08838833495974541</span><span class="n">j</span><span class="p">),</span>
 <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.08838832192122936</span><span class="o">-</span><span class="mf">0.08838833495974541</span><span class="n">j</span><span class="p">),</span>
 <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.08838832192122936</span><span class="o">-</span><span class="mf">0.08838833495974541</span><span class="n">j</span> <span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id52">
<h4>2.10.2.3 单振幅云计算<a class="headerlink" href="#id52" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li><p>single_amplitude_pmeasure(单振幅概率测量操作) ：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result3</span> <span class="o">=</span> <span class="n">QCM</span><span class="o">.</span><span class="n">single_amplitude_pmeasure</span><span class="p">(</span><span class="n">pmeasure_prog</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result3</span><span class="p">)</span>
</pre></div>
</div>
<p>​
需要传入的第二个参数是测量的振幅（十进制表示），输出结果如下,只会输出一个量子态对应的复数形式的振幅值：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mf">0.08838833056846361</span><span class="o">-</span><span class="mf">0.08838833850593952</span><span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id53">
<h4>2.10.2.4 噪声模拟云计算<a class="headerlink" href="#id53" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li><p>noise_measure(噪声虚拟机测量操作) ：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">QCM</span><span class="o">.</span><span class="n">set_noise_model</span><span class="p">(</span><span class="n">NoiseModel</span><span class="o">.</span><span class="n">BIT_PHASE_FLIP_OPRATOR</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.01</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.02</span><span class="p">])</span>
<span class="n">result4</span> <span class="o">=</span> <span class="n">QCM</span><span class="o">.</span><span class="n">noise_measure</span><span class="p">(</span><span class="n">measure_prog</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result4</span><span class="p">)</span>
</pre></div>
</div>
<p>通过 set_noise_model
设置噪声参数，第一个参数是噪声模型，后面分别是单门噪声参数和双门噪声参数，噪声模型的定义如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">enum</span> <span class="n">NOISE_MODEL</span>
<span class="p">{</span>
    <span class="n">DAMPING_KRAUS_OPERATOR</span><span class="p">,</span>
    <span class="n">DEPHASING_KRAUS_OPERATOR</span><span class="p">,</span>
    <span class="n">DECOHERENCE_KRAUS_OPERATOR_P1_P2</span><span class="p">,</span>
    <span class="n">BITFLIP_KRAUS_OPERATOR</span><span class="p">,</span>
    <span class="n">DEPOLARIZING_KRAUS_OPERATOR</span><span class="p">,</span>
    <span class="n">BIT_PHASE_FLIP_OPRATOR</span><span class="p">,</span>
    <span class="n">PHASE_DAMPING_OPRATOR</span><span class="p">,</span>
    <span class="n">DECOHERENCE_KRAUS_OPERATOR</span><span class="p">,</span>
    <span class="n">PAULI_KRAUS_MAP</span><span class="p">,</span>
    <span class="n">KRAUS_MATRIX_OPRATOR</span><span class="p">,</span>
    <span class="n">MIXED_UNITARY_OPRATOR</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>可以通过pyqpanda的枚举类 NoiseModel
来获取，该接口输出结果如下,左侧是量子态的二进制表示，右边表示测量对应的概率：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;00&#39;</span><span class="p">:</span> <span class="mf">0.26</span><span class="p">,</span>
 <span class="s1">&#39;01&#39;</span><span class="p">:</span> <span class="mf">0.21</span><span class="p">,</span>
 <span class="s1">&#39;10&#39;</span><span class="p">:</span> <span class="mf">0.29</span><span class="p">,</span>
 <span class="s1">&#39;11&#39;</span><span class="p">:</span> <span class="mf">0.24</span><span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id54">
<h4>2.10.2.5 求取量子态层析结果<a class="headerlink" href="#id54" title="永久链接至标题">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">qm</span> <span class="o">=</span> <span class="n">QCloud</span><span class="p">()</span>

<span class="n">qm</span><span class="o">.</span><span class="n">init_qvm</span><span class="p">(</span><span class="s2">&quot;E02BB115D5294012AA88D4BE82603984&quot;</span><span class="p">)</span>

<span class="n">qlist</span> <span class="o">=</span> <span class="n">qm</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="n">clist</span> <span class="o">=</span> <span class="n">qm</span><span class="o">.</span><span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
<span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">hadamard_circuit</span><span class="p">(</span><span class="n">qlist</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qlist</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">clist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">clist</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">qm</span><span class="o">.</span><span class="n">get_state_tomography_density</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="n">qm</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
</pre></div>
</div>
<p>使用方式类似蒙特卡洛测量，输出结果如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[(</span><span class="mf">0.2587544156749868</span><span class="o">-</span><span class="mf">8.004934191929294e-19</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.251211804846972</span><span class="o">+</span><span class="mf">0.001414451655940455</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.008943457002333129</span><span class="o">+</span><span class="mf">0.0014876032160007612</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.0040247742512866495</span><span class="o">+</span><span class="mf">0.007632530135083866</span><span class="n">j</span><span class="p">)],</span>
<span class="p">[(</span><span class="mf">0.2512118048469719</span><span class="o">-</span><span class="mf">0.001414451655940456</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.25003193002089275</span><span class="o">-</span><span class="mf">6.776263578034404e-19</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.0026098957997104447</span><span class="o">-</span><span class="mf">0.0145657172180014</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.001739623577306608</span><span class="o">+</span><span class="mf">0.003430686695967179</span><span class="n">j</span><span class="p">)],</span>
<span class="p">[(</span><span class="o">-</span><span class="mf">0.008943457002333132</span><span class="o">-</span><span class="mf">0.001487603216000763</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.002609895799710438</span><span class="o">+</span><span class="mf">0.0145657172180014</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.24548904782784528</span><span class="o">+</span><span class="mf">2.1684043449710093e-19</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.2290859282493824</span><span class="o">+</span><span class="mf">0.000791060320984212</span><span class="n">j</span><span class="p">)],</span>
<span class="p">[(</span><span class="o">-</span><span class="mf">0.0040247742512866495</span><span class="o">-</span><span class="mf">0.007632530135083866</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.001739623577306601</span><span class="o">-</span><span class="mf">0.0034306866959671776</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.2290859282493824</span><span class="o">-</span><span class="mf">0.0007910603209842113</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.2457246064762752</span><span class="o">-</span><span class="mf">2.710505431213761e-20</span><span class="n">j</span><span class="p">)]]</span>
</pre></div>
</div>
<p><em>注解：</em></p>
<ol class="arabic simple">
<li><p>使用对应的计算接口时，需要确认当前用户已经开通了该产品，否则可能会导致提交计算任务失败。</p></li>
<li><p>在噪声模拟时，退相干的单门噪声和双门参数参数分别有3个，不同于其他噪声。</p></li>
<li><p>本源悟源测量操作支持的测量次数范围在1000至10000之间，且目前仅支持6及以下量子比特的量子线路模拟，未来会加入其他的量子芯片，敬请期待。</p></li>
<li><p>在使用时遇到任何问题，请给我们提交 用户反馈
，我们看到后会尽快解决你的问题。</p></li>
</ol>
</section>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">pyQPanda</a></h1>








<h3>导航</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../api/index.html"><strong>1 基础介绍</strong></a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"><strong>2 深入学习</strong></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">2.1 <strong>量子逻辑门</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8"><strong>2.2 量子线路</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="#qwhile"><strong>2.3 QWhile</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="#qif"><strong>2.4 QIf</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="#id16"><strong>2.5 量子程序</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="#id19"><strong>2.6 量子虚拟机</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="#id36"><strong>2.7 量子比特池</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="#id40"><strong>2.8 量子测量</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="#id43"><strong>2.9 概率测量</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="#id46"><strong>2.10 本源量子云服务</strong></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tool/index.html">项目文档</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pyqpanda/test.html">pyqpanda</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="../api/index.html" title="上一章"><strong>1 基础介绍</strong></a></li>
      <li>Next: <a href="../tool/index.html" title="下一章">项目文档</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, BYLZ.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/database/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>
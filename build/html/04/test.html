
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>4 编译量子程序 &#8212; pyQPanda 1.0.0 文档</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="5555555555" href="../05/test.html" />
    <link rel="prev" title="3 量子程序信息" href="../tool/index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="id1">
<h1><strong>4 编译量子程序</strong><a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<section id="qasm">
<h2><strong>4.1 量子程序转化QASM</strong><a class="headerlink" href="#qasm" title="永久链接至标题">¶</a></h2>
<p>通过该功能模块，你可以解析通过QPanda2构建的量子程序，将其中包含的量子比特信息以及量子逻辑门操作信息提取出来，得到按固定格式存储的QASM指令集。</p>
<section id="id2">
<h3>4.1.1 QASM介绍<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>QASM(Quantum Assembly Language)是IBM公司提出的量子汇编语言，与
QRunes介绍 中的语法规则类似，一段QASM代码如下所示：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">OPENQASM</span> <span class="mf">2.0</span><span class="p">;</span>
<span class="n">include</span> <span class="s2">&quot;qelib1.inc&quot;</span><span class="p">;</span>
<span class="n">qreg</span> <span class="n">q</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="n">creg</span> <span class="n">c</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

<span class="n">x</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">h</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="n">tdg</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">sdg</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">cx</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">cx</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="n">u1</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">u2</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span><span class="n">pi</span><span class="p">)</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="n">u3</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span><span class="n">pi</span><span class="p">,</span><span class="n">pi</span><span class="p">)</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">cz</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="n">ccx</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
<span class="n">cu3</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span><span class="n">pi</span><span class="p">,</span><span class="n">pi</span><span class="p">)</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="n">measure</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">measure</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</pre></div>
</div>
<p>需要注意的是，QASM 的语法格式与 QRunes
形相似而神不同，主要区别有以下几点:</p>
<ul class="simple">
<li><p>QRunes 对于需要进行转置共轭操作的量子逻辑门与量子线路，需要将目标置于</p></li>
</ul>
<p>DAGGER 与 ENDAG- GER 语句之间，而 QASM 会直接进行转化。</p>
<ul class="simple">
<li><p>QRunes 支持对量子逻辑门与量子线路施加控制操作，而 QASM</p></li>
</ul>
<p>不支持，在对量子程序转化 QASM
指令集之前，会对其中包含的控制操作进行分解。</p>
<p>关于 QASM 更多详细信息的介绍、使用与体验请参考 <a class="reference external" href="https://quantumexperience.ng.bluemix.net/qx/editor">IBM Q Experience
量子云平台</a></p>
<p>QPanda2 提供了QASM 转换工具接口 conver_qprog_to_qasm
该接口使用非常简单，具体可参考下方示例程序。</p>
</section>
<section id="id3">
<h3>4.1.2 实例<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>下面的例程通过简单的接口调用演示了量子程序转化QASM指令集的过程</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">qvm</span> <span class="o">=</span> <span class="n">init_quantum_machine</span><span class="p">(</span><span class="n">QMachineType</span><span class="o">.</span><span class="n">CPU</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
    <span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
    <span class="n">cir</span> <span class="o">=</span> <span class="n">QCircuit</span><span class="p">()</span>
    <span class="n">cir</span> <span class="o">&lt;&lt;</span> <span class="n">T</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">S</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">cir</span>
    <span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">X</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">Y</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">CU</span><span class="p">(</span><span class="mf">1.2345</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>\
        <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">RX</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mf">3.14</span><span class="p">)</span>\
        <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">qasm</span> <span class="o">=</span> <span class="n">convert_qprog_to_qasm</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">qvm</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">qasm</span><span class="p">)</span>
    <span class="n">qvm</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
</pre></div>
</div>
<p>具体步骤如下:</p>
<ul class="simple">
<li><p>首先在主程序中用init_quantum_machine</p></li>
</ul>
<p>初始化一个量子虚拟机对象，用于管理后续一系列行为</p>
<ul class="simple">
<li><p>接着用 qAlloc_many 和 cAlloc_many 初始化量子比特与经典寄存器数目</p></li>
<li><p>然后调用 QProg 构建量子程序</p></li>
<li><p>最后调用接口 convert_qprog_to_qasm 输出QASM指令集。finalize()</p></li>
</ul>
<p>用于释放系统资源</p>
<p>运行结果如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">OPENQASM</span> <span class="mf">2.0</span><span class="p">;</span>
<span class="n">include</span> <span class="s2">&quot;qelib1.inc&quot;</span><span class="p">;</span>
<span class="n">qreg</span> <span class="n">q</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
<span class="n">creg</span> <span class="n">c</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
<span class="n">u3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.78539816339744828</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">u3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.5707963267948966</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="n">u3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mf">0.67259265358979359</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">u3</span><span class="p">(</span><span class="mf">3.1400000000000001</span><span class="p">,</span><span class="o">-</span><span class="mf">1.5707963267948966</span><span class="p">,</span><span class="mf">1.5707963267948966</span><span class="p">)</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="n">u3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mf">0.33629632679489674</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="n">q</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="n">cx</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">cx</span> <span class="n">q</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">u3</span><span class="p">(</span><span class="mf">3.1415926535897931</span><span class="p">,</span><span class="mf">3.14159265358979</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">u3</span><span class="p">(</span><span class="mf">3.1415926535897931</span><span class="p">,</span><span class="mf">6.2831853071795827</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="n">u3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.33629632679489674</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">measure</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">cx</span> <span class="n">q</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">u3</span><span class="p">(</span><span class="mf">1.1415926535897933</span><span class="p">,</span><span class="mf">3.1415926535897931</span><span class="p">,</span><span class="mf">2.8672963267948974</span><span class="p">)</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">u3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.5707963267948963</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="n">q</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="n">cx</span> <span class="n">q</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">u3</span><span class="p">(</span><span class="mf">1.1415926535897929</span><span class="p">,</span><span class="o">-</span><span class="mf">1.1947036732051033</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">cx</span> <span class="n">q</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">u3</span><span class="p">(</span><span class="mf">1.5707963267949037</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.3362963267948968</span><span class="p">)</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</pre></div>
</div>
</section>
</section>
<section id="id4">
<h2><strong>4.2 QASM转化为量子程序</strong><a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>通过该功能模块，你可以解析QASM文本文件，将其中的量子逻辑门操作信息提取出来，得到QPanda
2内部可操作的量子程序。</p>
<section id="id5">
<h3>4.2.1 QASM介绍<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>QASM的书写格式规范与例程可以参考量子程序转化QASM模块中的
<a class="reference external" href="#id1">QASM介绍</a> 部分。</p>
<p>QPanda 2提供了QASM文件转换工具接口 convert_qasm_to_qprog()
该接口使用非常简单，具体可参考下方示例程序。</p>
</section>
<section id="id6">
<h3>4.2.2 实例<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>接下来通过简单的接口调用演示了QASM转化量子程序的过程，</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">machine</span> <span class="o">=</span> <span class="n">init_quantum_machine</span><span class="p">(</span><span class="n">QMachineType</span><span class="o">.</span><span class="n">CPU</span><span class="p">)</span>

    <span class="c1"># 编写QASM文件</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;testfile.txt&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span><span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;// test QASM file</span>
<span class="s2">        OPENQASM 2.0;</span>
<span class="s2">        include &quot;qelib1.inc&quot;;</span>
<span class="s2">        qreg q[3];</span>
<span class="s2">        creg c[3];</span>
<span class="s2">        x q[0];</span>
<span class="s2">        x q[1];</span>
<span class="s2">        z q[2];</span>
<span class="s2">        h q[0];</span>
<span class="s2">        tdg q[1];</span>
<span class="s2">        measure q[0] -&gt; c[0];</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># QASM转换量子程序， 并返回量子程序、量子比特以及经典寄存器</span>
    <span class="n">prog_trans</span><span class="p">,</span> <span class="n">qv</span><span class="p">,</span> <span class="n">cv</span> <span class="o">=</span> <span class="n">convert_qasm_to_qprog</span><span class="p">(</span><span class="s2">&quot;testfile.txt&quot;</span><span class="p">,</span> <span class="n">machine</span><span class="p">)</span>

    <span class="c1"># 量子程序转换QASM</span>
    <span class="n">qasm</span> <span class="o">=</span> <span class="n">convert_qprog_to_qasm</span><span class="p">(</span><span class="n">prog_trans</span><span class="p">,</span><span class="n">machine</span><span class="p">)</span>

    <span class="c1"># 打印并对比转换结果</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">qasm</span><span class="p">)</span>
    <span class="n">destroy_quantum_machine</span><span class="p">(</span><span class="n">machine</span><span class="p">)</span>
</pre></div>
</div>
<p>具体步骤如下:</p>
<ul class="simple">
<li><p>首先编写 QASM，并将其保存到指定文件中</p></li>
<li><p>接着在主程序中用init_quantum_machine</p></li>
</ul>
<p>初始化一个量子虚拟机对象，用于管理后续一系列行为</p>
<ul class="simple">
<li><p>然后调用 convert_qasm_to_qprog 接口将 QASM 转换为量子程序</p></li>
<li><p>最后调用convert_qprog_to_qasm 接口，把量子程序转为</p></li>
</ul>
<p>QASM，通过比较量子程序执行结果，判断 QASM 是否正确转换成量子程序，并且用
destroy_quantum_machine 释放系统资源</p>
<p>运行结果如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">OPENQASM</span> <span class="mf">2.0</span><span class="p">;</span>
<span class="n">include</span> <span class="s2">&quot;qelib1.inc&quot;</span><span class="p">;</span>
<span class="n">qreg</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="n">creg</span> <span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="n">u3</span><span class="p">(</span><span class="mf">1.5707963267949037</span><span class="p">,</span><span class="mf">3.1415926535897931</span><span class="p">,</span><span class="mf">3.1415926535897931</span><span class="p">)</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">u3</span><span class="p">(</span><span class="mf">3.1415926535897931</span><span class="p">,</span><span class="mf">2.3561944901923386</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="n">u3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">3.1415926535897931</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">measure</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</pre></div>
</div>
<p><em>注解</em>：</p>
<p>上述示例中，由于QASM支持U3门，所以在QProg转QASM时，对量子线路做了优化，输出的QASM中只有U3门，这样可以有效降低量子线路深度。对于暂不支持的操作类型，可能会在QASM转化成量子程序的过程中发生错误。</p>
</section>
</section>
<section id="quil">
<h2><strong>4.3 量子程序转化为Quil</strong><a class="headerlink" href="#quil" title="永久链接至标题">¶</a></h2>
<section id="id7">
<h3>4.3.1 简介<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>Quil可以从一个很低级的层次直接描述量子程序、量子算法，它的地位类似于经典计算机中的硬件描述语言或者汇编语言。Quil基本采用“指令+参数列表”的设计方法。一个简单的量子程序例子如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="mi">0</span>
<span class="n">Y</span> <span class="mi">1</span>
<span class="n">CNOT</span> <span class="mi">0</span> <span class="mi">1</span>
<span class="n">H</span> <span class="mi">0</span>
<span class="n">RX</span><span class="p">(</span><span class="o">-</span><span class="mf">3.141593</span><span class="p">)</span> <span class="mi">0</span>
<span class="n">MEASURE</span> <span class="mi">1</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<ul class="simple">
<li><p>X 的作用是对目标量子比特进行 Pauli-X 门操作。与之类似的关键词有 Y 、Z</p></li>
</ul>
<p>、 H 等等。</p>
<ul class="simple">
<li><p>Y 的作用是对目标量子比特进行 Pauli-Y 门操作。</p></li>
<li><p>CNOT 的作用是对两个量子比特执行 CNOT</p></li>
</ul>
<p>操作。输入参数为控制量子比特序号和目标量子比特序号。</p>
<ul class="simple">
<li><p>H 的作用是对目标量子比特进行 Hadamard 门操作。</p></li>
<li><p>MEASURE</p></li>
</ul>
<p>的作用对目标量子比特进行测量并将测量结果保存在对应的经典寄存器里面，输入参数为目标量子比特序号和保存测量结果的经典寄存器序号。</p>
<p>上述仅为Quil指令集语法的一小部分， 详细介绍请参考
<a class="reference external" href="https://pyquil.readthedocs.io/en/stable/compiler.html">pyQuil</a> 。</p>
</section>
<section id="id8">
<h3>4.3.2 接口介绍<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>我们先用pyqpanda构建一个量子程序：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
<span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">X</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">Y</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>\
    <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">RX</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mf">3.14</span><span class="p">)</span>\
    <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cbits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>然后调用 convert_qprog_to_quil接口实现转化</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">quil</span> <span class="o">=</span> <span class="n">convert_qprog_to_quil</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">qvm</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id9">
<h3>4.3.3 实例<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">qvm</span> <span class="o">=</span> <span class="n">init_quantum_machine</span><span class="p">(</span><span class="n">QMachineType</span><span class="o">.</span><span class="n">CPU</span><span class="p">)</span>
    <span class="n">qubits</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">cbits</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>

    <span class="c1"># 构建量子程序</span>
    <span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">X</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">Y</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>\
        <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">RX</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mf">3.14</span><span class="p">)</span>\
        <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cbits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># 量子程序转换Quil， 并打印Quil</span>
    <span class="n">quil</span> <span class="o">=</span> <span class="n">convert_qprog_to_quil</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">qvm</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">quil</span><span class="p">)</span>

    <span class="n">qvm</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
</pre></div>
</div>
<p>运行结果：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="mi">0</span>
<span class="n">Y</span> <span class="mi">1</span>
<span class="n">H</span> <span class="mi">2</span>
<span class="n">RX</span><span class="p">(</span><span class="mf">3.140000</span><span class="p">)</span> <span class="mi">3</span>
<span class="n">MEASURE</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p><em>警告</em></p>
<p>新增接口 convert_qprog_to_quil()
，与老版本接口transform_qprog_to_quil()功能相同。</p>
</section>
</section>
<section id="id10">
<h2><strong>4.4 量子程序序列化</strong><a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<section id="id11">
<h3>4.4.1 介绍<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<p>定义一种协议将量子程序序列化为二进制数据，方便量子程序的存储与传输。</p>
</section>
<section id="id12">
<h3>4.4.2 接口介绍<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h3>
<p>我们先用pyqpanda构建一个量子程序：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
<span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> \
    <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> \
    <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> \
    <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
<p>然后调用convert_qprog_to_binary接口实现序列化</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prog_str</span> <span class="o">=</span> <span class="n">convert_qprog_to_binary</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">qvm</span><span class="p">)</span>
</pre></div>
</div>
<p><em>注解：</em></p>
<p>量子程序序列化是两个过程， 首先将量子程序序列化为二进制，
然后再将二进制以base64的格式编码，转化为字符串。</p>
</section>
<section id="id13">
<h3>4.4.3 实例<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">base64</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">qvm</span> <span class="o">=</span> <span class="n">init_quantum_machine</span><span class="p">(</span><span class="n">QMachineType</span><span class="o">.</span><span class="n">CPU</span><span class="p">)</span>
    <span class="n">qubits</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">cbits</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

    <span class="c1"># 构建量子程序</span>
    <span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
    <span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> \
        <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> \
        <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> \
        <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

    <span class="c1"># 量子程序序列化</span>
    <span class="n">binary_data</span> <span class="o">=</span> <span class="n">convert_qprog_to_binary</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">qvm</span><span class="p">)</span>

    <span class="c1"># 将得到的二进制数据以base64的方式编码，并打印</span>
    <span class="n">str_base64_data</span> <span class="o">=</span>  <span class="n">base64</span><span class="o">.</span><span class="n">encodebytes</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">binary_data</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">str_base64_data</span><span class="p">)</span>

    <span class="n">destroy_quantum_machine</span><span class="p">(</span><span class="n">qvm</span><span class="p">)</span>
</pre></div>
</div>
<p>运行结果：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sa">b</span><span class="s1">&#39;AAAAAAQAAAAEAAAABAAAAA4AAQAAAAAAJAACAAAAAQAkAAMAAQACACQABAACAAMA</span><span class="se">\n</span><span class="s1">&#39;</span>
</pre></div>
</div>
<p><em>注解：</em></p>
<p>二进制数据不能直接输出，以base64的编码格式编码，得到相应的字符串</p>
<p><em>警告：</em></p>
<p>新增接口 convert_qprog_to_binary() ，与老版本接口</p>
<p>transform_qprog_to_binary() 功能相同。</p>
</section>
</section>
<section id="id14">
<h2><strong>4.5 解析量子程序二进制文件</strong><a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h2>
<section id="id15">
<h3>4.5.1 简介<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h3>
<p>解析 量子程序序列化 方法序列化的量子程序。</p>
</section>
<section id="id16">
<h3>4.5.2 接口介绍<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h3>
<p>我们先用pyqPanda构建一个量子程序：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
<span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> \
    <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> \
    <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> \
    <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
<p>序列化之后经过base64编码之后得到的结果是（具体序列化的方法参照
量子程序序列化）</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sa">b</span><span class="s1">&#39;AAAAAAQAAAAEAAAABAAAAA4AAQAAAAAAJAACAAAAAQAkAAMAAQACACQABAACAAMA</span><span class="se">\n</span><span class="s1">&#39;</span>
</pre></div>
</div>
<p>现在就对这个结果反序列化，先将base64的结果解码成二进制数据：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">str_base64_data</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;AAAAAAQAAAAEAAAABAAAAA4AAQAAAAAAJAACAAAAAQAkAAMAAQACACQABAACAAMA</span><span class="se">\n</span><span class="s1">&#39;</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">base64</span><span class="o">.</span><span class="n">decodebytes</span><span class="p">(</span><span class="n">str_base64_data</span><span class="p">))]</span>
</pre></div>
</div>
<p>我们可以使用QPanda2封装的一个接口：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">convert_binary_data_to_qprog</span><span class="p">(</span><span class="n">qvm</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">qubits_parse</span><span class="p">,</span> <span class="n">cbits_parse</span><span class="p">,</span> <span class="n">parseProg</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="id17">
<h3>4.5.3 实例<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">base64</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">qvm</span> <span class="o">=</span> <span class="n">init_quantum_machine</span><span class="p">(</span><span class="n">QMachineType</span><span class="o">.</span><span class="n">CPU</span><span class="p">)</span>

    <span class="c1"># base64的方式解码，得到的二进制数据</span>
    <span class="n">str_base64_data</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;AAAAAAQAAAAEAAAABAAAAA4AAQAAAAAAJAACAAAAAQAkAAMAAQACACQABAACAAMA</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">base64</span><span class="o">.</span><span class="n">decodebytes</span><span class="p">(</span><span class="n">str_base64_data</span><span class="p">))]</span>

    <span class="c1"># 解析二进制数据，得到量子程序</span>
    <span class="n">parseProg</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>
    <span class="n">parseProg</span> <span class="o">=</span> <span class="n">convert_binary_data_to_qprog</span><span class="p">(</span><span class="n">qvm</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="c1"># 量子程序转换OriginIR并打印</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">convert_qprog_to_originir</span><span class="p">(</span><span class="n">parseProg</span><span class="p">,</span><span class="n">qvm</span><span class="p">))</span>

    <span class="n">destroy_quantum_machine</span><span class="p">(</span><span class="n">qvm</span><span class="p">)</span>
</pre></div>
</div>
<p>运行结果：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">QINIT</span> <span class="mi">4</span>
<span class="n">CREG</span> <span class="mi">4</span>
<span class="n">H</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">CNOT</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">CNOT</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="n">CNOT</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p><em>注解</em>：</p>
<p>可以运行出正确的结果说明可以将序列化的量子程序正确的解析出来</p>
<p><em>警告：</em></p>
<p>新增接口 convert_binary_data_to_qprog()
，与老版本接口transform_binary_data_to_qprog() 功能相同。</p>
</section>
</section>
<section id="originir">
<h2><strong>4.6 OriginIR 转化为量子程序</strong><a class="headerlink" href="#originir" title="永久链接至标题">¶</a></h2>
<p>通过该功能模块，你可以解析OriginIR文本文件，将其中的量子逻辑门操作信息提取出来，得到QPanda
2内部可操作的量子程序。</p>
<section id="id18">
<h3>4.6.1 OriginIR<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h3>
<p>OriginIR的书写格式规范与例程可以参考量子程序转化OriginIR模块中的
OriginIR介绍部分。</p>
<p>QPanda 2提供了OriginIR文件转换工具接口 convert_originir_to_qprog()
该接口使用非常简单，具体可参考下方示例程序。</p>
</section>
<section id="id19">
<h3>4.6.2实例<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h3>
<p>接下来通过简单的接口调用演示了OriginIR转化量子程序的过程</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>
<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">machine</span> <span class="o">=</span> <span class="n">init_quantum_machine</span><span class="p">(</span><span class="n">QMachineType</span><span class="o">.</span><span class="n">CPU</span><span class="p">)</span>

    <span class="c1"># 编写OriginIR文件</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;testfile.txt&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span><span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;QINIT 4</span>
<span class="s2">        CREG 4</span>
<span class="s2">        DAGGER</span>
<span class="s2">        X q[1]</span>
<span class="s2">        X q[2]</span>
<span class="s2">        CONTROL q[1], q[2]</span>
<span class="s2">        RY q[0], (1.047198)</span>
<span class="s2">        ENDCONTROL</span>
<span class="s2">        ENDDAGGER</span>
<span class="s2">        MEASURE q[0], c[0]</span>
<span class="s2">        QIF c[0]</span>
<span class="s2">        H q[1]</span>
<span class="s2">        H q[2]</span>
<span class="s2">        RZ q[2], (2.356194)</span>
<span class="s2">        CU q[2], q[3], (3.141593, 4.712389, 1.570796, -1.570796)</span>
<span class="s2">        CNOT q[2], q[1]</span>
<span class="s2">        ENDQIF</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># OriginIR转换量子程序, 返回转换后的量子程序、量子程序使用的量子比特以及经典寄存器</span>
    <span class="n">prog</span><span class="p">,</span> <span class="n">qv</span><span class="p">,</span> <span class="n">cv</span> <span class="o">=</span> <span class="n">convert_originir_to_qprog</span><span class="p">(</span><span class="s2">&quot;testfile.txt&quot;</span><span class="p">,</span> <span class="n">machine</span><span class="p">)</span>

    <span class="c1"># 量子程序转换OriginIR，打印并对比转换结果</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">convert_qprog_to_originir</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="n">machine</span><span class="p">))</span>

    <span class="n">destroy_quantum_machine</span><span class="p">(</span><span class="n">machine</span><span class="p">)</span>
</pre></div>
</div>
<p>具体步骤如下:</p>
<ul class="simple">
<li><p>首先编写OriginIR，并将其保存到指定文件中</p></li>
<li><p>接着在主程序中用 init_quantum_machine</p></li>
</ul>
<p>初始化一个量子虚拟机对象，用于管理后续一系列行为</p>
<ul class="simple">
<li><p>然后调用 convert_originir_to_qprog() 转化</p></li>
<li><p>最后调用 convert_qprog_to_originir()</p></li>
</ul>
<p>接口，把量子程序转为OriginIR，通过比较输入和生成的OriginIR
是否相同，判断OriginIR是否正确转换成量子程序，并且用
destroy_quantum_machine释放系统资源</p>
<p>运行结果如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">QINIT</span> <span class="mi">4</span>
<span class="n">CREG</span> <span class="mi">4</span>
<span class="n">DAGGER</span>
<span class="n">X</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">X</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="n">CONTROL</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="n">RY</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],(</span><span class="mf">1.047198</span><span class="p">)</span>
<span class="n">ENCONTROL</span>
<span class="n">ENDDAGGER</span>
<span class="n">MEASURE</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">QIF</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">H</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">ELSE</span>
<span class="n">H</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="n">RZ</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],(</span><span class="mf">2.356194</span><span class="p">)</span>
<span class="n">CU</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">],(</span><span class="mf">3.141593</span><span class="p">,</span><span class="mf">4.712389</span><span class="p">,</span><span class="mf">1.570796</span><span class="p">,</span><span class="o">-</span><span class="mf">1.570796</span><span class="p">)</span>
<span class="n">CNOT</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">ENDQIF</span>
</pre></div>
</div>
<p><em>注解：</em></p>
<p>对于暂不支持的操作类型，可能会在OriginIR转化成量子程序的过程中发生错误。</p>
<p><em>警告：</em></p>
<p>新增接口 convert_originir_to_qprog() ，与老版本接口
transformOriginIRToQProg() 功能相同。</p>
</section>
</section>
<section id="id20">
<h2><strong>4.7 量子程序转化OriginIR</strong><a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h2>
<p>通过该功能模块，你可以解析通过pyqpanda构建的量子程序，将其中包含的量子比特信息以及量子逻辑门操作信息提取出来，得到按固定格式存储的OriginIR。</p>
<section id="id21">
<h3>4.7.1 OriginIR介绍<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h3>
<p>OriginIR是基于QPanda的量子程序中间表示，对QPanda各种特性的支持有非常重要的作用。OriginIR不仅可以表示绝大部分量子逻辑门类型，表示针对量子线路的dagger操作，为量子线路添加控制比特，还可以支持QPanda独有的Qif、QWhile，可以实现量子程序内嵌经典程序。</p>
<p>OriginIR
主要内容有量子比特、经典寄存器、量子逻辑门、转置共轭操作、添加控制比特操作、QIf、QWhile、经典表达式。</p>
<section id="id22">
<h4>4.7.1.1 量子比特<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h4>
<p>OriginIR使用QINIT申请量子比特，其格式为QINIT后跟空格+量子比特总数。示例：QINIT6。需要注意的是除注释外QINIT必须出现在OriginIR程序的第一行。
在使用量子比特时，OriginIR使用q[i]表示某个具体的量子比特，此处i为量子比特的编号，i可为无符号数字型常量，也可为变量，同时也可使用c[i]组成的表达式代替，示例：q[1],q[c[0]],q[c[1]+c[2]+c[3]]。</p>
</section>
<section id="id23">
<h4>4.7.1.2 经典寄存器<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h4>
<p>OriginIR使用CREG申请经典寄存器，其格式为CREG后跟空格+经典寄存器总数。示例：CREG
6；
在使用经典寄存器时，OriginIR使用c[i]表示某个具体的经典寄存器，i为经典寄存器编号,此处i必须为无符号数字型常量；示例：c[1]。</p>
</section>
<section id="id24">
<h4>4.7.1.3 量子逻辑门<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h4>
<p>OriginIR把量子逻辑门分为以下几个种类：单门无参数型关键字；单门一个参数型；单门两个参数；单门三个参数；单门四个参数；双门无参数；双门一个参数；双门四个参数；三门无参数。
需要注意的是所有单门操作，目标量子比特可以是整个量子比特数组或者单个量子比特。如果是整个量子比特数组时例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="n">q</span>
</pre></div>
</div>
<p>当量子比特数组大小为3时则等效为：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">H</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">H</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>1、单门无参数型关键字：H、T、S、X、Y、Z、X1、Y1、Z1、I；表示无参数类型的单量子逻辑门；格式为量子逻辑门关键字+空格+目标量子比特。示例</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>2、单门一个参数型关键字：RX、RY、RZ、U1；表示有一个参数的单量子逻辑门；格式为量子逻辑门关键字+空格+目标量子比特+逗号+(偏转角度)。示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">RX</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],(</span><span class="mf">1.570796</span><span class="p">)</span>
</pre></div>
</div>
<p>3、
单门两个参数型关键字：U2、RPhi；表示有两个参数的单量子逻辑门；格式为量子逻辑门关键字+空格+目标量子比特+逗号+（两个偏转角度）。示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">U2</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],(</span><span class="mf">1.570796</span><span class="p">,</span><span class="o">-</span><span class="mf">3.141593</span><span class="p">)</span>
</pre></div>
</div>
<p>4、
单门三个参数型关键字：U3；表示有三个参数的单量子逻辑门；格式为量子逻辑门关键字+空格+目标量子比特+逗号+（三个偏转角度）。示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">U3</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],(</span><span class="mf">1.570796</span><span class="p">,</span><span class="mf">4.712389</span><span class="p">,</span><span class="mf">1.570796</span><span class="p">)</span>
</pre></div>
</div>
<p>5、单门四个参数关键字：U4；表示有四个参数的单量子逻辑门；格式为量子逻辑门关键字+空格+目标量子比特+逗号+（四个偏转角度）。示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">U4</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],(</span><span class="mf">3.141593</span><span class="p">,</span><span class="mf">4.712389</span><span class="p">,</span><span class="mf">1.570796</span><span class="p">,</span><span class="o">-</span><span class="mf">3.141593</span><span class="p">)</span>
</pre></div>
</div>
<p>6、双门无参数型关键字：CNOT、CZ、ISWAP、SQISWAP、SWAP；表示无参数的双量子逻辑门；格式为量子逻辑门关键字+空格+控制比特+逗号+目标比特。示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CNOT</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>7、双门一个参数型关键字：ISWAPTHETA、CR；表示有一个参数的单量子逻辑门；格式为量子逻辑门关键字+空格+控制比特+逗号+目标比特+逗号+(偏转角度)。示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CR</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],(</span><span class="mf">1.570796</span><span class="p">)</span>
</pre></div>
</div>
<p>8、双门四个参数型关键字：CU；表示有四个参数的单量子逻辑门；格式为量子逻辑门关键字+空格+控制比特+逗号+目标比特+逗号+（四个偏转角度）。示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CU</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">],(</span><span class="mf">3.141593</span><span class="p">,</span><span class="mf">4.712389</span><span class="p">,</span><span class="mf">1.570796</span><span class="p">,</span><span class="o">-</span><span class="mf">3.141593</span><span class="p">)</span>
</pre></div>
</div>
<p>9、
三门无参数型关键字：TOFFOLI；表示无参数的三量子逻辑门；格式为量子逻辑门关键字+空格+控制比特1+逗号+控制比特2+逗号+目标比特。示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">TOFFOLI</span>  <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="id25">
<h4>4.7.1.4 转置共轭操作<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h4>
<p>OriginIR中可以对一个或多个量子逻辑门进行转置共轭操作，OriginIR使用DAGGER和
ENDDAGGER关键字定义转置共轭操作的范围，一个DAGGER必须有一个ENDDAGGER匹配，示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DAGGER</span>
<span class="n">H</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">CNOT</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">ENDDAGGER</span>
</pre></div>
</div>
</section>
<section id="id26">
<h4>4.7.1.5 添加控制比特操作<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h4>
<p>OriginIR中可以对一个或多个量子逻辑门添加控制比特，OriginIR使用CONTROL 和
ENDCONTROL关键字定义添加控制比特的范围，CONTROL后跟空格+控制比特列表；示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CONTROL</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="n">H</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">CNOT</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">ENDCONTROL</span>
</pre></div>
</div>
</section>
<section id="qif">
<h4>4.7.1.6 QIF<a class="headerlink" href="#qif" title="永久链接至标题">¶</a></h4>
<p>OriginIR中可以表示量子条件判断程序，它通过QIF、ELSE、ENDIF框定量子条件判断程序的不同分支的范围。QIF必须匹配一个ENDIF，如果QIF有两个分支则需要有ELSE，如果QIF只有一个分支则不需要有ELSE；QIF后跟空格+判断表达式。示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1、QIF只有一个条件分支
QIF c[0]==c[1]
H q[0]
CNOT q[0],q[1]
ENDIF

2、QIF有两个条件分支
QIF c[0]+c[1]&lt;5
H q[0]
CNOT q[0],q[1]
ELSE
H q[0]
X q[1]
ENDIF
</pre></div>
</div>
</section>
<section id="qwhile">
<h4>4.7.1.7 QWHILE<a class="headerlink" href="#qwhile" title="永久链接至标题">¶</a></h4>
<p>OriginIR中可以表示量子循环判断程序，它通过QWHILE和ENDQWHILE框定循环判断程序的范围，QWHILE必须匹配一个ENDQWHILE；QWHILE后跟空格+判断表达式。示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">QWHILE</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">5</span>
<span class="n">H</span> <span class="n">q</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
<span class="n">ENDQWHILE</span>
</pre></div>
</div>
</section>
<section id="id27">
<h4>4.7.1.8 经典表达式<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h4>
<p>OriginIR可以在量子程序中嵌入经典表达式，如c[0]==c[1]+c[2]；使用示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">QWHILE</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">5</span>
<span class="n">H</span> <span class="n">q</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
<span class="n">ENDQWHILE</span>
</pre></div>
</div>
<p>该示例表示对q[0]~q[4]比特做H门操作；经典表达式中必须是经典寄存器和常量组成的表达式；经典表达式的操作符有</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">PLUS</span> <span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">},</span>
<span class="p">{</span><span class="n">MINUS</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">},</span>
<span class="p">{</span><span class="n">MUL</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">},</span>
<span class="p">{</span><span class="n">DIV</span><span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="p">},</span>
<span class="p">{</span><span class="n">EQUAL</span><span class="p">,</span> <span class="s2">&quot;==&quot;</span> <span class="p">},</span>
<span class="p">{</span> <span class="n">NE</span><span class="p">,</span> <span class="s2">&quot;!=&quot;</span> <span class="p">},</span>
<span class="p">{</span> <span class="n">GT</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span> <span class="p">},</span>
<span class="p">{</span> <span class="n">EGT</span><span class="p">,</span> <span class="s2">&quot;&gt;=&quot;</span> <span class="p">},</span>
<span class="p">{</span> <span class="n">LT</span><span class="p">,</span> <span class="s2">&quot;&lt;&quot;</span> <span class="p">},</span>
<span class="p">{</span> <span class="n">ELT</span><span class="p">,</span> <span class="s2">&quot;&lt;=&quot;</span> <span class="p">},</span>
<span class="p">{</span><span class="n">AND</span><span class="p">,</span> <span class="s2">&quot;&amp;&amp;&quot;</span><span class="p">},</span>
<span class="p">{</span><span class="n">OR</span><span class="p">,</span> <span class="s2">&quot;||&quot;</span><span class="p">},</span>
<span class="p">{</span><span class="n">NOT</span><span class="p">,</span> <span class="s2">&quot;!&quot;</span><span class="p">},</span>
<span class="p">{</span><span class="n">ASSIGN</span><span class="p">,</span> <span class="s2">&quot;=&quot;</span> <span class="p">}</span>
</pre></div>
</div>
</section>
<section id="measure">
<h4>4.7.1.9 MEASURE操作<a class="headerlink" href="#measure" title="永久链接至标题">¶</a></h4>
<p>MEASURE表示对指定的量子比特进行测量操作，并把结果保存到指定的经典寄存器中。MEASURE后跟空格+目标量子比特+‘，’+目标经典寄存器。示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MEASURE</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>如果申请的量子比特和经典寄存器数量相同。可以使用q表示所有量子比特，c表示所有经典比特。示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MEAUSRE</span> <span class="n">q</span><span class="p">,</span><span class="n">c</span>
</pre></div>
</div>
<p>如果量子比特和经典比特数量都为3，则等效为</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MEAUSRE</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">MEAUSRE</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">MEAUSRE</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="reset">
<h4>4.7.1.10 RESET操作<a class="headerlink" href="#reset" title="永久链接至标题">¶</a></h4>
<p>RESET操作是将操作的量子比特的量子态恢复到0态。格式为RESET+空格+目标量子比特。其中目标量子比特可以是整个量子比特数组或者单个量子比特。
示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">RESET</span> <span class="n">q</span>

<span class="n">RESET</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="barrier">
<h4>4.7.1.11 BARRIER操作<a class="headerlink" href="#barrier" title="永久链接至标题">¶</a></h4>
<p>BARRIER操作是将操作的量子比特进行阻断，防止在线路优化和执行过程。
格式为BARRIER+空格+目标量子比特。其中目标量子比特可以是整个量子比特数组或者单个、多个量子比特。示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BARRIER</span> <span class="n">q</span>
<span class="n">BARRIER</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">BARRIER</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="qgate">
<h4>4.7.1.12 QGATE操作<a class="headerlink" href="#qgate" title="永久链接至标题">¶</a></h4>
<p>QGATE为自定义逻辑门操作，可以将多个逻辑门组合成一个新的逻辑门使用。
它通过QGATE和ENDQGATE框定自定义逻辑门的范围。同时需要注意的是，自定义逻辑门的形参名不能与上述相关关键字冲突。</p>
<p>用户自定义逻辑门的声明规则如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>QGATE UserDefinedeGateName BitParameter,(angle)
//UserDefinedeGateName,用户自定义逻辑门名称，string
//BitParameter,用户自定义逻辑门形参信息，string
//angle,角度信息，string
//其他的相关信息【&quot;,&quot;、&quot;(&quot;等】必须按照定义的格式书写
//其中&quot;,”及以后的相关信息可空，即角度信息可空
</pre></div>
</div>
<p>下面是一个简单的例子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">QGATE</span> <span class="n">new_H</span> <span class="n">a</span>
<span class="n">H</span> <span class="n">a</span>
<span class="n">X</span> <span class="n">a</span>
<span class="n">ENDQGATE</span>


<span class="n">QGATE</span> <span class="n">new_RX</span> <span class="n">a</span><span class="p">,(</span><span class="n">b</span><span class="p">)</span>
<span class="n">RX</span> <span class="n">a</span><span class="p">,(</span><span class="n">PI</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="n">b</span><span class="p">)</span>
<span class="n">CONTROL</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">RX</span> <span class="n">a</span><span class="p">,(</span><span class="o">-</span><span class="mf">3.141593</span><span class="p">)</span>
<span class="n">DAGGER</span>
<span class="n">H</span> <span class="n">a</span>
<span class="n">ENDDAGGER</span>
<span class="n">ENDCONTROL</span>
<span class="n">DAGGER</span>
<span class="n">H</span> <span class="n">a</span>
<span class="n">DAGGER</span>
<span class="n">H</span> <span class="n">a</span>
<span class="n">ENDDAGGER</span>
<span class="n">ENDDAGGER</span>
<span class="n">ENDQGATE</span>
</pre></div>
</div>
<p>用户可以在申请完量子比特和经典寄存器之后，调用自定义逻辑门，格式如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> UserDefinedeGateName  argue,(angle)
//UserDefinedeGateName,用户自定义逻辑门名称，string,与上述定义部分保持一致
//BitParameter,用户自定义逻辑门形参信息，string，必须是q[x],x需要小于申请的量子比特的数目
//angle,角度信息，string，可以是数字，或者与PI相关的表达式
</pre></div>
</div>
<p>下面是一个简单的例子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">new_H</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">new_RX</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],(</span><span class="n">PI</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id28">
<h4>4.7.1.13 OriginIR程序示例<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h4>
<p>OPE算法</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">QINIT</span> <span class="mi">3</span>
<span class="n">CREG</span> <span class="mi">2</span>
<span class="n">H</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="n">H</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">H</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">CONTROL</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">RX</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],(</span><span class="o">-</span><span class="mf">3.141593</span><span class="p">)</span>
<span class="n">ENCONTROL</span>
<span class="n">CONTROL</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">RX</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],(</span><span class="o">-</span><span class="mf">3.141593</span><span class="p">)</span>
<span class="n">RX</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],(</span><span class="o">-</span><span class="mf">3.141593</span><span class="p">)</span>
<span class="n">ENCONTROL</span>
<span class="n">DAGGER</span>
<span class="n">H</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">CR</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],(</span><span class="mf">1.570796</span><span class="p">)</span>
<span class="n">H</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">ENDDAGGER</span>
<span class="n">MEASURE</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">MEASURE</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>QPanda2提供了OriginIR转换工具接口 std::string
convert_qprog_to_originir)
该接口使用非常简单，具体可参考下方示例程序。</p>
</section>
</section>
<section id="id29">
<h3>4.7.2 实例<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h3>
<p>下面的例程通过简单的接口调用演示了量子程序转化OriginIR的过程</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">machine</span> <span class="o">=</span> <span class="n">init_quantum_machine</span><span class="p">(</span><span class="n">QMachineType</span><span class="o">.</span><span class="n">CPU</span><span class="p">)</span>
    <span class="n">qlist</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">clist</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">prog</span> <span class="o">=</span> <span class="n">create_empty_qprog</span><span class="p">()</span>
    <span class="n">prog_cir</span> <span class="o">=</span> <span class="n">create_empty_circuit</span><span class="p">()</span>

    <span class="c1"># 构建量子线路</span>
    <span class="n">prog_cir</span> <span class="o">&lt;&lt;</span> <span class="n">Y</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">qlist</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># 构建QWhile， 使用量子线路为循环分支</span>
    <span class="n">qwhile</span> <span class="o">=</span> <span class="n">create_while_prog</span><span class="p">(</span><span class="n">clist</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">prog_cir</span><span class="p">)</span>

    <span class="c1"># 构建量子程序， 将QWhile插入到量子程序中</span>
    <span class="n">prog</span> <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">Measure</span><span class="p">(</span><span class="n">qlist</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">clist</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">qwhile</span>

    <span class="c1"># 量子程序转换QriginIR，并打印OriginIR</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">convert_qprog_to_originir</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="n">machine</span><span class="p">))</span>

    <span class="n">destroy_quantum_machine</span><span class="p">(</span><span class="n">machine</span><span class="p">)</span>
</pre></div>
</div>
<p>具体步骤如下:</p>
<ul class="simple">
<li><p>首先在主程序中用init_quantum_machine</p></li>
</ul>
<p>初始化一个量子虚拟机对象，用于管理后续一系列行为</p>
<ul class="simple">
<li><p>接着用 qAlloc_many 和 cAlloc_many 初始化量子比特与经典寄存器数目</p></li>
<li><p>然后调用 create_empty_qprog 构建量子程序</p></li>
<li><p>最后调用接口 convert_qprog_to_originir 输出OriginIR字符串，并用</p></li>
</ul>
<p>destroyQuantumMachine 释放系统资源</p>
<p>运行结果如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">QINIT</span> <span class="mi">4</span>
<span class="n">CREG</span> <span class="mi">4</span>
<span class="n">H</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="n">MEASURE</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">QWHILE</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">Y</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="n">H</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="n">CNOT</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">ENDQWHILE</span>
</pre></div>
</div>
<p><em>注解：</em></p>
<p>对于暂不支持的操作类型，OriginIR会显示UnSupported
XXXNode，其中XXX为具体的节点类型。</p>
<p><em>警告：</em></p>
<p>新增接口 convert_qprog_to_originir() ，与老版本接口
transformQProgToOriginIR() 功能相同。</p>
</section>
</section>
<section id="id30">
<h2><strong>4.8 量子程序匹配拓扑结构</strong><a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h2>
<p>量子计算设备存在量子比特之间的有限连接，使得只能在有限的量子位对上应用两个量子位门。量子程序应用到目标设备时，必须转换原始的量子程序以适应硬件限制，让双量子比特门中的两个量子比特能够满足物理拓扑结构，从而让双量子位门正常作用；
当前解决方案中多数需要在无法相互作用的两个量子比特间插入额外的SWAP操作，以便将逻辑量子位“移动”到它们可以相互作用的位置。我们称这种解决方法为量子程序匹配拓扑结构。</p>
<section id="id31">
<h3>4.8.1 接口说明<a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h3>
<p>当前版本中存在两种思路的匹配拓扑方法：</p>
<p>接口 topology_match:</p>
<p>通过采用线路分层以及A*搜索算法，在匹配过程中，让插入的SWAP操作个数近似达到最少，使得算法的整体近似消耗达到最少。
该接口需要传入5个参数，其中分别为
构建的量子程序、使用的量子比特位集合、初始化的虚拟机指针、使用的SWAP操作的方式、拓扑结构的类型；并且返回映射后的量子程序。</p>
</section>
<section id="id32">
<h3>4.8.2 实例<a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h3>
<p>topology_match 实例</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyqpanda</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">qvm</span> <span class="o">=</span> <span class="n">CPUQVM</span><span class="p">()</span>
    <span class="n">qvm</span><span class="o">.</span><span class="n">init_qvm</span><span class="p">()</span>

    <span class="n">qv</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">qAlloc_many</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">cAlloc_many</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">src_prog</span> <span class="o">=</span> <span class="n">QProg</span><span class="p">()</span>

    <span class="c1"># 构建量子程序</span>
    <span class="n">src_prog</span> <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qv</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> \
            <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> \
            <span class="o">&lt;&lt;</span> <span class="n">CNOT</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qv</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> \
            <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> \
            <span class="o">&lt;&lt;</span> <span class="n">CZ</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> \
            <span class="o">&lt;&lt;</span> <span class="n">T</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  \
            <span class="o">&lt;&lt;</span> <span class="n">S</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>  \
            <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="p">(</span><span class="n">qv</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

    <span class="c1"># 对src_prog进行概率测量，得到结果results_1</span>
    <span class="n">qvm</span><span class="o">.</span><span class="n">directly_run</span><span class="p">(</span><span class="n">src_prog</span><span class="p">)</span>
    <span class="n">results_1</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">pmeasure_no_index</span><span class="p">(</span><span class="n">qv</span><span class="p">)</span>

    <span class="c1"># 对src_prog进行拓扑匹配，得到匹配IBM_QX5_ARCH拓扑结构的量子程序out_prog</span>
    <span class="n">out_prog</span><span class="p">,</span> <span class="n">out_qv</span> <span class="o">=</span> <span class="n">topology_match</span><span class="p">(</span><span class="n">src_prog</span><span class="p">,</span> <span class="n">qv</span><span class="p">,</span> <span class="n">qvm</span><span class="p">,</span> <span class="n">CNOT_GATE_METHOD</span><span class="p">,</span> <span class="n">IBM_QX5_ARCH</span><span class="p">)</span>

    <span class="c1"># 对out_prog进行概率测量，得到结果results_2</span>
    <span class="n">qvm</span><span class="o">.</span><span class="n">directly_run</span><span class="p">(</span><span class="n">out_prog</span><span class="p">)</span>
    <span class="n">results_2</span> <span class="o">=</span> <span class="n">qvm</span><span class="o">.</span><span class="n">pmeasure_no_index</span><span class="p">(</span><span class="n">out_qv</span><span class="p">)</span>

    <span class="c1"># 对比概率测量结果results_1和results_2, 打印相同结果</span>
    <span class="nb">len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">results_1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">results_2</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">results_1</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">-</span> <span class="n">results_2</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">1.0e-6</span> <span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">results_1</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The results are different&quot;</span><span class="p">)</span>

    <span class="n">destroy_quantum_machine</span><span class="p">(</span><span class="n">qvm</span><span class="p">)</span>
</pre></div>
</div>
<p>具体步骤如下:</p>
<ul class="simple">
<li><p>首先创建量子虚拟机、量子寄存器、经典寄存器</p></li>
<li><p>编写量子程序 src_prog ，对该量子程序进行概率测量得到结果 result_1</p></li>
<li><p>接着调用 topology_match() 对 src_prog</p></li>
</ul>
<p>进行符合特定物理结构的线路映射，得到适配特定物理结构的量子程序 out_prog</p>
<ul class="simple">
<li><p>对量子程序 out_prog 进行概率测量得到结果 result_2</p></li>
<li><p>由于量子程序映射只是对原线路增加额外的 SWAP</p></li>
</ul>
<p>操作，以适配物理拓扑结构，并不影响线路的结构。所以对比结果 result_1 和
result_2 ，如果结果一致，则线路映射正确。</p>
<p>运行结果如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">0.4999999701976776</span>
<span class="mf">0.0</span>
<span class="mf">0.0</span>
<span class="mf">0.0</span>
<span class="mf">0.0</span>
<span class="mf">0.0</span>
<span class="mf">0.0</span>
<span class="mf">0.0</span>
<span class="mf">0.4999999701976776</span>
<span class="mf">0.0</span>
<span class="mf">0.0</span>
<span class="mf">0.0</span>
<span class="mf">0.0</span>
<span class="mf">0.0</span>
<span class="mf">0.0</span>
<span class="mf">0.0</span>
</pre></div>
</div>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">pyQPanda</a></h1>








<h3>导航</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../api/index.html"><strong>5 Utility tool</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../database/index.html"><strong>2 深入学习</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../tool/index.html"><strong>3 量子程序信息</strong></a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"><strong>4 编译量子程序</strong></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#qasm"><strong>4.1 量子程序转化QASM</strong></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">4.1.1 QASM介绍</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">4.1.2 实例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id4"><strong>4.2 QASM转化为量子程序</strong></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id5">4.2.1 QASM介绍</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">4.2.2 实例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#quil"><strong>4.3 量子程序转化为Quil</strong></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id7">4.3.1 简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">4.3.2 接口介绍</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">4.3.3 实例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id10"><strong>4.4 量子程序序列化</strong></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id11">4.4.1 介绍</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">4.4.2 接口介绍</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id13">4.4.3 实例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id14"><strong>4.5 解析量子程序二进制文件</strong></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id15">4.5.1 简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id16">4.5.2 接口介绍</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id17">4.5.3 实例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#originir"><strong>4.6 OriginIR 转化为量子程序</strong></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id18">4.6.1 OriginIR</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id19">4.6.2实例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id20"><strong>4.7 量子程序转化OriginIR</strong></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id21">4.7.1 OriginIR介绍</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id22">4.7.1.1 量子比特</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id23">4.7.1.2 经典寄存器</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id24">4.7.1.3 量子逻辑门</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id25">4.7.1.4 转置共轭操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id26">4.7.1.5 添加控制比特操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="#qif">4.7.1.6 QIF</a></li>
<li class="toctree-l4"><a class="reference internal" href="#qwhile">4.7.1.7 QWHILE</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id27">4.7.1.8 经典表达式</a></li>
<li class="toctree-l4"><a class="reference internal" href="#measure">4.7.1.9 MEASURE操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reset">4.7.1.10 RESET操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="#barrier">4.7.1.11 BARRIER操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="#qgate">4.7.1.12 QGATE操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id28">4.7.1.13 OriginIR程序示例</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id29">4.7.2 实例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id30"><strong>4.8 量子程序匹配拓扑结构</strong></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id31">4.8.1 接口说明</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id32">4.8.2 实例</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../05/test.html">5555555555</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06/test.html">66666666</a></li>
<li class="toctree-l1"><a class="reference internal" href="../07/test.html">7777777</a></li>
<li class="toctree-l1"><a class="reference internal" href="../08/test.html">88888888</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="../tool/index.html" title="上一章"><strong>3 量子程序信息</strong></a></li>
      <li>Next: <a href="../05/test.html" title="下一章">5555555555</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, BYLZ.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/04/test.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>